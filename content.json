{"meta":{"title":"Domacles","subtitle":null,"description":"We can only see a short distance ahead, but we can see plenty there that needs to be done.","author":"Domacles","url":"https://domacles.github.io"},"pages":[{"title":"分类","date":"2017-03-01T12:24:16.000Z","updated":"2017-06-26T01:42:02.350Z","comments":false,"path":"categories/index.html","permalink":"https://domacles.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-01T12:31:24.000Z","updated":"2017-06-26T01:42:02.350Z","comments":false,"path":"about/index.html","permalink":"https://domacles.github.io/about/index.html","excerpt":"","text":"毕业院校: 山东农业大学 信息科学与工程学院 计算机科学与技术专业2016届 山东农业大学ACM队 技术栈: C++ 11/14 (熟悉) 计算机图形学 - 图形算法 (入门) 计算机图形学 - 图形渲染 (入门) 经典算法 (熟悉) Node.js used TypeScript (入门) 准备入栈: Qt Vulkan 计算机图形学 - 点云重建 计算机图形学 - 模型质量整体优化"},{"title":"标签","date":"2017-03-01T12:21:09.000Z","updated":"2017-06-26T01:42:02.352Z","comments":false,"path":"tags/index.html","permalink":"https://domacles.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vulkan Samples Tutorial 8","slug":"Vulkan Samples Tutorial 8","date":"2017-04-27T19:00:00.000Z","updated":"2017-06-26T01:42:02.348Z","comments":true,"path":"2017/04/28/Vulkan Samples Tutorial 8/","link":"","permalink":"https://domacles.github.io/2017/04/28/Vulkan Samples Tutorial 8/","excerpt":"","text":"Draw Cube Waiting for a Swapchain Buffer Beginning the Render Pass Bind the Pipeline Bind the Descriptor Sets Bind the Vertex Buffer Set the Viewport and Scissors Rectangle Draw the Vertices Transitioning the Swapchain Image for Presenting Memory barrier approach Submit the Command Buffer Wait for Command Buffer to Complete Present the Swapchain Buffer to Display Draw Cube本章节代码在15-draw_cube.cpp文件中。 我们已经完成绝大部分工作了，这里是我们需要做的最后一步，将Vlukan图像画到屏幕上。 Waiting for a Swapchain Buffer开始画图之前，样例程序需要渲染一个目标swapchain图像作为底色。用函数vkAcquireNextImageKHR()获取swapchain列表的一个索引，这样就能知道用哪一个framebuffer作为渲染目标。这也是下一个可用于渲染的图像。1234567res = vkCreateSemaphore(info.device, &amp;imageAcquiredSemaphoreCreateInfo, NULL, &amp;imageAcquiredSemaphore);// Get the index of the next available swapchain image:res = vkAcquireNextImageKHR(info.device, info.swap_chain, UINT64_MAX, imageAcquiredSemaphore, VK_NULL_HANDLE, &amp;info.current_buffer); 第一帧，可能不需要使用信号（semaphore），因为swapchain中的所有图像都可用。在随后要正要提交的GPU命令之前，确保图像可用仍然是好的实现方案。如果图像采样在多帧中都有所改变，比如动画，那就很有必要等待硬件完成图像渲染，以便再次使用该图像的swapchain。 注意，本样例不需要等待其他东西的完成。我们仅仅创建信号，并且将它和图像联系起来，以便用这个信号推迟命令缓存的提交，直到图像准备好进行渲染。 Beginning the Render Pass在以前的章节，我们已经定义了渲染通道，所以在命令缓存中，我们可以直接通过设置一个开启渲染通道的命令来启用渲染通道：123456789101112VkRenderPassBeginInfo rp_begin;rp_begin.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;rp_begin.pNext = NULL;rp_begin.renderPass = info.render_pass;rp_begin.framebuffer = info.framebuffers[info.current_buffer];rp_begin.renderArea.offset.x = 0;rp_begin.renderArea.offset.y = 0;rp_begin.renderArea.extent.width = info.width;rp_begin.renderArea.extent.height = info.height;rp_begin.clearValueCount = 2;rp_begin.pClearValues = clear_values;vkCmdBeginRenderPass(info.cmd, &amp;rp_begin, VK_SUBPASS_CONTENTS_INLINE); 在上面这段代码中: 注意，我们已经创建了一个命令缓存，并且，在本样例前面的地方通过调用init_command_buffer()和execute_begin_command()将命令缓冲区设置成了记录模式(recording mode)。 我们提供了之前定义的渲染通道和用vkAcquireNextImageKHR()返回的索引选择的framebuffer。 clear值来作为初始化值是用来设置背景颜色为深灰色，并且深度缓存的clear值设为深度缓存的“far”(clear_values)值。 info.render_pass中剩下的需要的信息在以前已经设置好，然后我们只需要直接将它们插入到命令缓存，开始渲染通道。 Bind the Pipeline下一步绑定管线到命令缓存：1vkCmdBindPipeline(info.cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, info.pipeline); 在前面章节中我们定义了管线并绑定，而在这里绑定它到info.cmd，告诉GPU怎样渲染后面的图元（graphics primitives）。 VK_PIPELINE_BIND_POINT_GRAPHICS告诉GPU这是图形管线，而不是计算管线。 注意，这个指令是一个命令缓存指令，而在单个命令缓存中，程序可能定义许多图形管线，并且在他们之间转换。 Bind the Descriptor Sets我们已经定义的描述符集描述了着色程序怎样期望发现它的输入数据，例如MVP变换。这里是给GPU的信息：123vkCmdBindDescriptorSets(info.cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, info.pipeline_layout, 0, 1, info.desc_set.data(), 0, NULL); 注意，在命令缓存中，如果我们想要改变着色器程序怎样找到数据，我们可以绑定不同的描述符。例如，我们想要在命令缓存中间改变转换，我们可以用一个不同的描述符来指向一个不同的MVP转换。 Bind the Vertex Buffer我们在vertex_buffer样例中创建一个vertex buffer，并用顶点数据填充。这里，告诉GPU怎样找到它：123vkCmdBindDescriptorSets(info.cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, info.pipeline_layout, 0, 1, info.desc_set.data(), 0, NULL); 这个命令绑定顶点缓存（vertex buffer）或缓存区（buffers）到命令缓存。我们只能绑定一个缓存，但是，可以用它来绑定多次。 Set the Viewport and Scissors Rectangle前面我们指明视口（viewport）和剪切（scissors）是动态的状态，意味着可以用命令缓存指令（a command buffer command）设置它们。所以，我们在这里需要设置它们。下面是init_viewports()中设置视区的代码：1234567info.viewport.height = (float)info.height;info.viewport.width = (float)info.width;info.viewport.minDepth = (float)0.0f;info.viewport.maxDepth = (float)1.0f;info.viewport.x = 0;info.viewport.y = 0;vkCmdSetViewport(info.cmd, 0, NUM_VIEWPORTS, &amp;info.viewport); 设置剪切矩形（scissors rectangle）的代码类似。 由于许多应用程序可能在运行时改变窗口的大小，所以使上面的viewport为动态(dynamic)的变量最合适。当窗口大小改变时，这样就避免了重建管线的做法。 Draw the Vertices最后，给GPU发送一个绘制命令，将顶点送到管线中完成渲染通道。12vkCmdDraw(info.cmd, 12 * 3, 1, 0, 0);vkCmdEndRenderPass(info.cmd); 其中，vkCmdDraw命令告诉GPU绘制一次36个顶点的图形。现在你已经设置好了画一系列独立的三角形的管线的最初部分，即GPU会绘制12个三角形。 vkCmdEndRenderPass命令表示渲染通道的结束，但是命令缓冲区仍然“开着(open)”并且样例也没有结束命令的发送。 Transitioning the Swapchain Image for Presenting当GPU进行渲染时，目标交换链(swapchain)的图像布局格式是VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL，是一种最适合GPU渲染的布局格式。在之前的章节中，我们定义渲染通道时，将这个布局格式设置到了子通道的定义中。但这种布局格式对于显示硬件扫描的图像输出到显示设备来说并不是最好的布局格式。比如，用于渲染的优化的GPU内存布局是平铺的(“tiled”)，如同之前在渲染通道章节所讲的那样。但显示硬件会为输出选择线性内存布局。使用VK_IMAGE_LAYOUT_PRESENT_SRC_KHR布局可以指定将要被显示的图像。 在渲染通道章节中，你已经了解过布局转换，在这里我们通过指定在颜色图像附件(color image attachment)定义中的属性finalLayout为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR来转换格式：12345678910VkAttachmentDescription attachments[2];attachments[0].format = info.format;attachments[0].samples = NUM_SAMPLES;attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;attachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;attachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;attachments[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;attachments[0].flags = 0; Memory barrier approach注意，内存屏障(Memory Barrier)方法是另外一种用于完成布局转换的方法，该方法是通过发送另外一个内存屏障命令到内存缓冲中。这种替代方法在某些情况下是有用的，比如那些没有使用渲染通道的命令提交。我们可以在copy_blit_image中找到一个适用场景。虽然在本样例中并没有用到，但在统一文件夹下的其他样例中可以看到。 在本样例中，我们使用了一个渲染通道，但如果我们设置颜色附件的finalLayout属性值为渲染通道样例中的创建的渲染通道的initialLayout属性的值，那我们仍然可以使用内存屏障方法：12attachments[0].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;attachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; 这就需要我们使用另外一个管线内存平常来完成布局转换，方法与set_image_layout()完成布局转换的过程有很多相类似的地方：123456789101112131415161718VkImageMemoryBarrier prePresentBarrier = &#123;&#125;;prePresentBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;prePresentBarrier.pNext = NULL;prePresentBarrier.srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;prePresentBarrier.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;prePresentBarrier.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;prePresentBarrier.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;prePresentBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;prePresentBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;prePresentBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;prePresentBarrier.subresourceRange.baseMipLevel = 0;prePresentBarrier.subresourceRange.levelCount = 1;prePresentBarrier.subresourceRange.baseArrayLayer = 0;prePresentBarrier.subresourceRange.layerCount = 1;prePresentBarrier.image = info.buffers[info.current_buffer].image;vkCmdPipelineBarrier(info.cmd, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, NULL, 0, NULL, 1, &amp;prePresentBarrier); 上面的代码并没有在本样例中出现，但可以在copy_blit_image样例中找到。 一旦该命令在渲染通道结束后执行，那图像缓冲就做好了显示的准备了。当然，对于深度缓冲图像布局格式并不需要进行转换。 Submit the Command Buffer要时刻明确，现在还没有发送给GPU任何一条命令(都在命令缓冲区中)。现在使用下面的调用，表示完成命令记录：1res = vkEndCommandBuffer(info.cmd); 我们需要创建一个监视围栏(fence)用于报告GPU何时完成任务。我们需要指定GPU何时完成任务，这样才能避免太早开始下一次呈现显示：123456VkFenceCreateInfo fenceInfo;VkFence drawFence;fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;fenceInfo.pNext = NULL;fenceInfo.flags = 0;vkCreateFence(info.device, &amp;fenceInfo, NULL, &amp;drawFence); 现在，我们可以提交命令缓冲区了：1234567891011121314const VkCommandBuffer cmd_bufs[] = &#123;info.cmd&#125;;VkPipelineStageFlags pipe_stage_flags = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;VkSubmitInfo submit_info[1] = &#123;&#125;;submit_info[0].pNext = NULL;submit_info[0].sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;submit_info[0].waitSemaphoreCount = 1;submit_info[0].pWaitSemaphores = &amp;imageAcquiredSemaphore;submit_info[0].pWaitDstStageMask = &amp;pipe_stage_flags;submit_info[0].commandBufferCount = 1;submit_info[0].pCommandBuffers = cmd_bufs;submit_info[0].signalSemaphoreCount = 0;submit_info[0].pSignalSemaphores = NULL;res = vkQueueSubmit(info.queue, 1, submit_info, drawFence); VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT表示该命令在管线最后阶段完成执行。 imageAcquiredSemaphore是图像绘制之前完成准备的等待信号，如本章节前面所讲。它让驱动得知何时交换链图像是可用的。然后再将命令提交到GPU。当GPU执行完命令时，GPU会给围栏drawFence发送绘制完成的信号。 Wait for Command Buffer to CompletevkWaitForFences()用于等待命令缓冲区中命令执行完成。当命令会花很长时间才能完成，该函数应当在一个循环中去调用它。但本样例中比较简单，并没有使用这种做法。123do &#123; res = vkWaitForFences(info.device, 1, &amp;drawFence, VK_TRUE, FENCE_TIMEOUT);&#125; while (res == VK_TIMEOUT); 此时，我们就知道了交换链图像缓冲区已经做好了显示的准备。 Present the Swapchain Buffer to Display接下来就可以直接将交换链图像显示出来：12345678910VkPresentInfoKHR present;present.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;present.pNext = NULL;present.swapchainCount = 1;present.pSwapchains = &amp;info.swap_chain;present.pImageIndices = &amp;info.current_buffer;present.pWaitSemaphores = NULL;present.waitSemaphoreCount = 0;present.pResults = NULL;res = vkQueuePresentKHR(info.queue, &amp;present); 现在，我们可以看到显示器出现一个画有立方体的窗口了。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 7","slug":"Vulkan Samples Tutorial 7","date":"2017-04-27T05:20:00.000Z","updated":"2017-06-26T01:42:02.346Z","comments":true,"path":"2017/04/27/Vulkan Samples Tutorial 7/","link":"","permalink":"https://domacles.github.io/2017/04/27/Vulkan Samples Tutorial 7/","excerpt":"","text":"Create a Graphics Pipeline Dynamic State Pipeline Vertex Input State Pipeline Vertex Input Assembly State Pipeline Rasterization State Pipeline Color Blend State Pipeline Viewport State Pipeline Depth Stencil State Pipeline Multisample State Pulling It All Together - Create Graphics Pipeline Create a Graphics Pipeline本章节代码在14-init_pipeline.cpp文件中。 我们将更进一步把所有之前进行的步骤放到一起去画立方体。接下来，我们通过设置图形管线（graphics pipeline）来设置渲染的GPU。 图形管线由着色器阶段、管线布局、渲染通道和固定功能的管线阶段。在以前的章节中定义了着色器阶段和管线布局。在此，将设置余下的固定功能的管线阶段。包括填充一些创建管线的”create info”数据结构。在将图像片元(fragments)放到帧缓存之前，这里完成的大部分工作是设置预片段(per-fragment)操作。简图如下： 下一步将设置管线状态对象，即上图中右下角的灰色框。最后一步是连接其它对象指向左上角的紫色管线框，为了完成图形管线的定义。 Dynamic State在命令缓冲区运行期间，动态管线状态(Dynamic State)是能被命令缓冲区改变的。预先通知哪些状态是动态状态对驱动器可能有用，因为它可能会为命令缓存的执行创建GPU对象。 样例提供了一个在命令缓存执行期间会改变状态的状态列表。在此，代码以创建动态状态列表开始，开始时这些动状态都是disabled。1234567VkDynamicState dynamicStateEnables[VK_DYNAMIC_STATE_RANGE_SIZE];VkPipelineDynamicStateCreateInfo dynamicState = &#123;&#125;;memset(dynamicStateEnables, 0, sizeof dynamicStateEnables);dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;dynamicState.pNext = NULL;dynamicState.pDynamicStates = dynamicStateEnables;dynamicState.dynamicStateCount = 0; 样例表明样例将使用命令缓存动态地改变一些状态，所以，当设置视区（viewport）和剪切（scissors）矩形时，样例会改变dynamicStateEnables数组。代码通过修改dynamicStateEnables来保持清楚地设置viewport和scissors。 Pipeline Vertex Input State当创建vertex buffer时，我们已经对vertex输入状态进行了初始化，因为它在创建时就直接完成了。输入状态包括顶点数据的格式和管理。可以回顾vertexbuffer样例去查看vi_binding和vi_attribs变量是如何设置的。12345678VkPipelineVertexInputStateCreateInfo vi;vi.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;vi.pNext = NULL;vi.flags = 0;vi.vertexBindingDescriptionCount = 1;vi.pVertexBindingDescriptions = &amp;info.vi_binding;vi.vertexAttributeDescriptionCount = 2;vi.pVertexAttributeDescriptions = info.vi_attribs; Pipeline Vertex Input Assembly State输入组件的状态（input assembly state）主要是什么时候声明顶点如何从我们想要画的几何图形中得到。例如，顶点可能形成三角带（triangle strip）和三角扇（triangle fan）。这里，我们仅仅用三角形列表，每三个点描述一个三角形。123456VkPipelineInputAssemblyStateCreateInfo ia;ia.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;ia.pNext = NULL;ia.flags = 0;ia.primitiveRestartEnable = VK_FALSE;ia.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; Pipeline Rasterization State在GPU中，下面的数据结构设置了光栅化(rasterization)操作。1234567891011121314VkPipelineRasterizationStateCreateInfo rs;rs.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;rs.pNext = NULL;rs.flags = 0;rs.polygonMode = VK_POLYGON_MODE_FILL;rs.cullMode = VK_CULL_MODE_BACK_BIT;rs.frontFace = VK_FRONT_FACE_CLOCKWISE;rs.depthClampEnable = VK_TRUE;rs.rasterizerDiscardEnable = VK_FALSE;rs.depthBiasEnable = VK_FALSE;rs.depthBiasConstantFactor = 0;rs.depthBiasClamp = 0;rs.depthBiasSlopeFactor = 0;rs.lineWidth = 1.0f; 用常见值设置这些字段。我们可以通过GL函数glFrontFace()的来识别frontFace成员。 Pipeline Color Blend State绑定是另一个end of the fixed pipe操作，即在目的地设置像素的简单替换。123456789101112131415161718192021VkPipelineColorBlendStateCreateInfo cb;cb.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;cb.pNext = NULL;cb.flags = 0;VkPipelineColorBlendAttachmentState att_state[1];att_state[0].colorWriteMask = 0xf;att_state[0].blendEnable = VK_FALSE;att_state[0].alphaBlendOp = VK_BLEND_OP_ADD;att_state[0].colorBlendOp = VK_BLEND_OP_ADD;att_state[0].srcColorBlendFactor = VK_BLEND_FACTOR_ZERO;att_state[0].dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;att_state[0].srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;att_state[0].dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;cb.attachmentCount = 1;cb.pAttachments = att_state;cb.logicOpEnable = VK_FALSE;cb.logicOp = VK_LOGIC_OP_NO_OP;cb.blendConstants[0] = 1.0f;cb.blendConstants[1] = 1.0f;cb.blendConstants[2] = 1.0f;cb.blendConstants[3] = 1.0f; 注意，在每个附件基础(per-attachment basis)上，我们都提供了一些配置信息的。在管线中，每一个颜色附件需要一个VkPipelineColorBlendAttachmentState。在这种情况下，这里只有一个颜色附件。 colorWriteMask从R, G, B(, A)四个类型中选择出支持写（writing）的组件（components）。这里，可以选择这4个组件。 我们禁用了blendEnable，表示剩下的att_state[0]中的设置与绑定(blending)并不是至关紧要的。 我们也可以禁用pixel-writing逻辑操作，因为，这个样例仅仅在写像素到帧缓存时做了一个简单的替换。 绑定常量用于一些”blend factors”(如，VK_BLEND_FACTOR_CONSTANT_COLOR)，或仅是用于设置一些东西使其合理，但在这个样例没有使用到。 Pipeline Viewport Statedraw_cube样例在命令缓存中用命令设置视口(viewport)和裁剪(scissors)矩形。下面的代码告诉驱动哪些viewport和scissors状态是动态的，并忽略pViewPorts和pScissors成员。12345678910VkPipelineViewportStateCreateInfo vp = &#123;&#125;;vp.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;vp.pNext = NULL;vp.flags = 0;vp.viewportCount = 1;dynamicStateEnables[dynamicState.dynamicStateCount++] = VK_DYNAMIC_STATE_VIEWPORT;vp.scissorCount = 1;dynamicStateEnables[dynamicState.dynamicStateCount++] = VK_DYNAMIC_STATE_SCISSOR;vp.pScissors = NULL;vp.pViewports = NULL; Pipeline Depth Stencil State紧接着，通过建立共用配置和禁用模版操作(stencil operations)来完成后端固定功能( fixed-function)的初始化：12345678910111213141516171819VkPipelineDepthStencilStateCreateInfo ds;ds.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;ds.pNext = NULL;ds.flags = 0;ds.depthTestEnable = VK_TRUE;ds.depthWriteEnable = VK_TRUE;ds.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;ds.depthBoundsTestEnable = VK_FALSE;ds.minDepthBounds = 0;ds.maxDepthBounds = 0;ds.stencilTestEnable = VK_FALSE;ds.back.failOp = VK_STENCIL_OP_KEEP;ds.back.passOp = VK_STENCIL_OP_KEEP;ds.back.compareOp = VK_COMPARE_OP_ALWAYS;ds.back.compareMask = 0;ds.back.reference = 0;ds.back.depthFailOp = VK_STENCIL_OP_KEEP;ds.back.writeMask = 0;ds.front = ds.back; 因为我们想使用深度缓存，所以开启了深度缓存writing和testing。此外，一般使用VK_COMPARE_OP_LESS_OR_EQUAL设置深度缓存比较操作。最后，我们禁用了模板（stencil）操作，由于这个样例并不需要它。 Pipeline Multisample State这个例子我们不打算做任何精细的多采样，所以通过建立无多采样来完成管线设置。12345678910VkPipelineMultisampleStateCreateInfo ms;ms.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;ms.pNext = NULL;ms.flags = 0;ms.pSampleMask = NULL;ms.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;ms.sampleShadingEnable = VK_FALSE;ms.alphaToCoverageEnable = VK_FALSE;ms.alphaToOneEnable = VK_FALSE;ms.minSampleShading = 0.0; Pulling It All Together - Create Graphics Pipeline最后，我们综合所有需要的信息来创建管线。1234567891011121314151617181920212223VkGraphicsPipelineCreateInfo pipeline;pipeline.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;pipeline.pNext = NULL;pipeline.layout = info.pipeline_layout;pipeline.basePipelineHandle = VK_NULL_HANDLE;pipeline.basePipelineIndex = 0;pipeline.flags = 0;pipeline.pVertexInputState = &amp;vi;pipeline.pInputAssemblyState = &amp;ia;pipeline.pRasterizationState = &amp;rs;pipeline.pColorBlendState = &amp;cb;pipeline.pTessellationState = NULL;pipeline.pMultisampleState = &amp;ms;pipeline.pDynamicState = &amp;dynamicState;pipeline.pViewportState = &amp;vp;pipeline.pDepthStencilState = &amp;ds;pipeline.pStages = info.shaderStages;pipeline.stageCount = 2;pipeline.renderPass = info.render_pass;pipeline.subpass = 0;res = vkCreateGraphicsPipelines(info.device, NULL, 1, &amp;pipeline, NULL, &amp;info.pipeline); info.pipeline_layout、info.shaderStages和and info.render_pass成员已在以前的章节初始化。这个结构中的余下成员在本章节设置。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 6","slug":"Vulkan Samples Tutorial 6","date":"2017-04-26T06:26:00.000Z","updated":"2017-06-26T01:42:02.345Z","comments":true,"path":"2017/04/26/Vulkan Samples Tutorial 6/","link":"","permalink":"https://domacles.github.io/2017/04/26/Vulkan Samples Tutorial 6/","excerpt":"","text":"Shaders Compiling GLSL Shaders into SPIR-V Creating Vulkan Shader Modules Create the Framebuffers The vulkan Framebuffer Create a Vertex Buffer Creating the Vertex Buffer Object Allocating the Vertex Buffer Memory Store the Vertex Data in the Buffer Describing the Input Vertex Data Binding the Vertex Buffer to a Render Pass Shaders本章节代码在11-init_shaders.cpp文件中。 Compiling GLSL Shaders into SPIR-VVulkan中底层着色器（shader）使用的代码是SPIR-V。样例程序调用了一个函数工具，使用着色器编译器将GLSL转换了成SPIR-V：1GLSLtoSPV(VK_SHADER_STAGE_VERTEX_BIT, vertShaderText, vtx_spv); 着色器源代码在vertShaderText变量中，编译SPIR-V得到的返回值在vtx_spv中，它是一个unsigned int的vector，适合于存储SPIR-V代码。 从样例代码中可以找到顶点着色器的着色源码，注意，样例同时也提供了片段着色器（fragment shader）源码，他们的编译方法和过程类似。 同时，我们应当注意到，代码中给出的着色器代码都是简单的着色器。顶点着色器只是简单地把颜色传递到输出，并且用MVP矩阵（MVP可以参考以前的章节）变换位置。片段着色器甚至更简单，仅仅传递颜色至输出。 在这个简单的样例中，有两个着色阶段：顶点着色阶段和片段着色阶段，顺序存储在info.shaderStages中。 Creating Vulkan Shader Modules在Vulkan中，通过创建VkShaderModule来经过编译的着色器代码，并且存储在结构体VkPipelineShaderStageCreateInfo中，这个结构体在后面的另一个样例中用到，作为创建整个图形管线的一部分。12345678VkShaderModuleCreateInfo moduleCreateInfo;moduleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;moduleCreateInfo.pNext = NULL;moduleCreateInfo.flags = 0;moduleCreateInfo.codeSize = vtx_spv.size() * sizeof(unsigned int);moduleCreateInfo.pCode = vtx_spv.data();res = vkCreateShaderModule(info.device, &amp;moduleCreateInfo, NULL, &amp;info.shaderStages[0].module); 注意，从GLSL转换到的SPIR-V代码是用来创建着色器模块(shader module)。用同样的过程为片段着色器创建vkShaderModule，并将它存储在info.shaderStages[1].module中。 与此同时，也可以完成一些着色器管线阶段(pipeline shader stage)中附加的creation info的初始化：123456info.shaderStages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;info.shaderStages[0].pNext = NULL;info.shaderStages[0].pSpecializationInfo = NULL;info.shaderStages[0].flags = 0;info.shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;info.shaderStages[0].pName = &quot;main&quot;; 现在，着色器可以运行了。 Create the Framebuffers本章节代码在12-init_frame_buffers.cpp文件中。 The vulkan Framebuffer帧缓冲（Framebuffers）是一种被渲染通道对象使用的内存附件集合。这些内存附件的例子包括前面创建的例子中的颜色图像缓存和深度缓存。渲染时，帧缓存提供了渲染通道需要的附件。 在前面的交换链（swapchain）样例中，我们创建一个交换链，它为在交换链中的每一“帧”(frame)提供一个颜色图像附件。在深度缓存样例中，我们也创建了一个深度图象附件，它被每一帧中每一个图像附件重复使用。 在渲染通道(render pass)样例中，我们创建了一个描述附件性质的渲染通道，但是事实上我们并没有将实际资源（即images）与渲染通道连接起来。帧缓存本质上将实际的附件与渲染通道联系起来。 举个例子，如果swapchain有两帧，那么需要创建两个帧缓存。第一个帧缓存包括第一个颜色图像缓存，它可以在swapchain例子中用vkGetSwapchainImagesKHR()获取到。在depthbuffer例子中，第一个帧缓存也包括我们创建的单个深度缓存。第二个帧缓存包括第二个颜色图像缓存和在第一个帧缓存中使用的同一个深度缓存。 看样例代码，我们开始时声明了一个包括两个附件的数组，预初始化第二个附件给深度缓存，这是因为它会被所有的帧缓存使用。随后我们填充第一个附件。注意，”view”对象的作用是引用这个图像，由于视图对象(view)包括用来描述缓存的格式和用法的附加元数据(metadata)。12VkImageView attachments[2];attachments[1] = info.depth.view; 接下来，填充create info结构:123456789VkFramebufferCreateInfo fb_info = &#123;&#125;;fb_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;fb_info.pNext = NULL;fb_info.renderPass = info.render_pass;fb_info.attachmentCount = 2;fb_info.pAttachments = attachments;fb_info.width = info.width;fb_info.height = info.height;fb_info.layers = 1; 样例支持运行时确定的swapchain数量，所以动态地分配帧缓存处理的数组array。12info.framebuffers = (VkFramebuffer *)malloc(info.swapchainImageCount * sizeof(VkFramebuffer)); 对每一个帧缓存，设置第一个附件给swapchain中每个各自的颜色图像缓存，设置第二个附件给相同的深度缓存，所以被所有帧缓存共享。1234for (int i = 0; i &lt; info.swapchainImageCount; i++) &#123; attachments[0] = info.buffers[i].view; res = vkCreateFramebuffer(info.device, &amp;fb_info, NULL, &amp;info.framebuffers[i]);&#125; 注意，在renderpass样例中，我们定义的相同的渲染通道也与每一个帧缓存相联系。 Create a Vertex Buffer本章节代码在13-init_vertex_buffer.cpp文件中。 顶点缓存（vertex buffer）是可见的CPU和可见的GPU缓存，包括描述渲染对象的几何结构的顶点数据（vertex data）。总之，顶点数据由数据的位置（x,y,z）和选择的颜色（color）、法线（normal）或其它的信息组成。像其它的3D APIs，在画图操作中，这里的方法是用顶点数据填充缓存，并把它传给GPU。 Creating the Vertex Buffer Object创建vertex buffer与创建uniform buffer几乎一致，就像在uniform sample中一样，以创建一个缓存对象开始。12345678910VkBufferCreateInfo buf_info = &#123;&#125;;buf_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;buf_info.pNext = NULL;buf_info.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;buf_info.size = sizeof(g_vb_solid_face_colors_Data);buf_info.queueFamilyIndexCount = 0;buf_info.pQueueFamilyIndices = NULL;buf_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;buf_info.flags = 0;res = vkCreateBuffer(info.device, &amp;buf_info, NULL, &amp;info.vertex_buffer.buf); 创建uniform buffer对象与vertex buffer对象实际上唯一不同是usage参数的设置。 立方体数据（g_vb_solid_face_colors_Data）由定义了12个三角形的36个顶点构成，立方体的6个面中，每一个面包括2个三角形。每一个三角形都有一个面的颜色。从cube_data.h中可以看到真实的数据。 Allocating the Vertex Buffer Memory此外，分配vertex buffer的步骤与分配uniform buffer的步骤相似。首先，查询获取内存的requirements，它包括考虑机器的限制条件，如对齐（alignment）。从样例中的代码中可以看到这个过程与uniform样例非常相似。 Store the Vertex Data in the Buffer一旦vertex buffer的内存分配完，然后进行内存映射操作、使用顶点数据进行初始化、之后进行解除映射操作(在之前使用uniform buffer时，解释过为何要在使用之后立即解除映射)：12345678uint8_t *pData;res = vkMapMemory(info.device, info.vertex_buffer.mem, 0, mem_reqs.size, 0, (void **)&amp;pData);memcpy(pData, g_vb_solid_face_colors_Data, sizeof(g_vb_solid_face_colors_Data));vkUnmapMemory(info.device, info.vertex_buffer.mem); 最后一步，将内存绑定到缓存对象上。12res = vkBindBufferMemory(info.device, info.vertex_buffer.buf, info.vertex_buffer.mem, 0); Describing the Input Vertex Data样例中的顶点数据如下所示：1234struct Vertex &#123; float posX, posY, posZ, posW; // Position data float r, g, b, a; // Color&#125;; 我们需要创建一个顶点输入的绑定来为GPU描述数据的组织形式。虽然是在这里进行vi_binding和vi_attribs成员的设置，但他们将在后面的样例中作为创建图形管线的一部分。注意看西面顶点数据的格式，这是个很好的参考样例：123456789101112info.vi_binding.binding = 0;info.vi_binding.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;info.vi_binding.stride = sizeof(g_vb_solid_face_colors_Data[0]);info.vi_attribs[0].binding = 0;info.vi_attribs[0].location = 0;info.vi_attribs[0].format = VK_FORMAT_R32G32B32A32_SFLOAT;info.vi_attribs[0].offset = 0;info.vi_attribs[1].binding = 0;info.vi_attribs[1].location = 1;info.vi_attribs[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;info.vi_attribs[1].offset = 16; stride表示一个顶点数据的大小，也可以表示成获取下一个顶点数据需要的字节长度。 binding和location成员表示他们在GLSL着色器源码中各自的值。可以在shader样例中回顾shader源码。 尽管我们让vi_attribs[0]表示顶点位置数据的信息，但在info.vi_attribs[0]中，实际上是format属性用4个字节颜色格式(即VK_FORMAT_R32G32B32A32_SFLOAT)来为GPU描述数据格式的。那vi_attribs[1]很自然地使用来表示颜色数据，所以我们可以看到info.vi_attribs[1].format的颜色格式设置。 offset成员表示顶点数据中每个属性的偏移量(在OpenGL中也有这个概念，即第一个顶点数据是从0字节开始的，第一个颜色数据是从16字节开始的，然后根据它们的format来计算下一个数据的位置)。 Binding the Vertex Buffer to a Render Pass由于后面样例可以看到，我们可以掠过render pass中的大部分代码。然后找到绑定vertex buffer到render pass的代码：12345678vkCmdBeginRenderPass(info.cmd, &amp;rp_begin, VK_SUBPASS_CONTENTS_INLINE);vkCmdBindVertexBuffers(info.cmd, 0, /* Start Binding */ 1, /* Binding Count */ &amp;info.vertex_buffer.buf, /* pBuffers */ offsets); /* pOffsets */vkCmdEndRenderPass(info.cmd); 注意，在渲染通道中，只能用一个render pass链接vertex buffer；也就是，当记录命令缓冲区时，在vkCmdBeginRenderPass和vkCmdEndRenderPass之间的代码进行额。当画图时，必须告诉GPU用什么顶点缓存。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 5","slug":"Vulkan Samples Tutorial 5","date":"2017-04-24T16:00:00.000Z","updated":"2017-06-26T01:42:02.343Z","comments":true,"path":"2017/04/25/Vulkan Samples Tutorial 5/","link":"","permalink":"https://domacles.github.io/2017/04/25/Vulkan Samples Tutorial 5/","excerpt":"","text":"Create a Render Pass Image Layout Transition Create the Render Pass Create a Render Pass本章节代码在10-init_render_pass.cpp文件中。 渲染通道(Render Pass)指的是：指定的附件集合(collection of attachments)、子通道(subpasses)、渲染过程用到的依赖(dependencies)这一些概念的渲染操作范畴。1个渲染通道至少包含1个子通道。传递给驱动的信息，可以使驱动了解程序希望什么时候开始渲染以及渲染什么东西，还可以让驱动提供渲染操作的硬件优化急速。 我们通过使用vkCreateRenderPass()来定义渲染通道，然后使用vkCmdBeginRenderPass()和vkCmdEndRenderPass()向命令缓冲区插入一个渲染通道实例。 在本章节内容中，我们只是定义并创建渲染通道，但直到本章节代码结束都没有将它插入到命令缓冲区中。 在本章节样例中，渲染通道附件(render pass attachments)用到了颜色附件(color attachment)，就是从Swapchian获得的图像，还用到了深度/模版附件(depth/stencil attachment)，附件使用的深度缓冲区是在之前创建的。 图像附件必须在使用时准备好，这样它们才能够被添加到渲染通道实例上用于在命令缓冲区中执行。准备的过程包括图像布局(Image Layouts)从初始未定义阶段转换到在渲染通道优化阶段的过程。我们将会在本章节了解在创建渲染通道之前，图像布局的转换过程。 Image Layout TransitionThe Need for Alternate Memory Access Patterns 图像的布局(Image Layouts)指的是图像像素如何从二维坐标系映射到图像内存偏移的方法。比较有代表性的布局是，图像数据使用的线性映射：2D图像按照一行接着一行的方法存储到连续的内存中：1offset = rowCoord * pitch + colCoord pitch表示一行的大小。该变量通常是和图像的宽度相同，但通常会填充一些字节，使得图像数据的起始位置满足GPU内存地址的对齐要求。 线性的布局很适合沿着行来读写连续的像素，即按照colCoord变化的方向，但是，多数图形操作包含一些读取相邻行像素的操作，即按照rowCoord的方向。如果图像非常宽，那采用线性映射的方法会导致每次存取相邻行内存地址的跨度很大。在多级缓存内存系统中，由于内存地址转换跨度过大造成TLB未命中或者缓存未命中太多，导致性能低下问题的出现。 为了减少这些低效现象的出现，许多GPU硬件实现支持优化optimal/tiled的内存存取方案。在一种优化的布局设计中，图像中间的矩形形状的像素被存储到一段连续的内存中，其他的矩形形状的像素也按照中心矩阵的存放方法存到内存中。举个例子，由左上角[16, 32]到右下角[31, 47]建立的像素矩阵，可以圈出一块16 x 16的像素块，该像素块存到一块连续的内存上。行与行之间的间隔就变得不长了。 如果GPU想要填充上面所讲的像素块，比如可以使用先沟通的颜色，这种方法就可以用一个相对开销较小的内存操作方法来填充这256个像素组成的像素块。 下面是一个简单的2 x 2的平铺图，注意，蓝色的像素在线性内存布局中两部分想个比较远，而在平铺布局中相隔就比较近： 大部分图像内存布局的实现，采用更复杂的平铺方法，且平铺的大小大于2 x 2(这让我想起了用希尔伯特曲线填充平面空间的方法)。 Vulkan Control Over the Layout 由于上面所解释的那样，GPU会为了提升渲染效率才支持优化的布局方案。优化的布局方案通常是不透明的(opaque)，这表示优化布局方案格式的具体细节并不是公开的或者不会让别人知道如何读写图像数据。 举个例子，假如你想让GPU使用一种优化的布局方案来渲染图像，但是如果你希望让CPU读取和理解最终需要渲染的图像的数据，你需要从优化的布局方案改成一般的布局方案。 在Vulkan中，从一种布局转换到另外一种布局叫做布局转换(layout transition)。下面三种途径的任何一种，都能够让我们实现布局转换： 内存栅格化命令(Memory Barrier Command)，通过vkCmdPipelineBarrier来控制 了解渲染通道最终布局规范(Render Pass final layout specification) 了解渲染通道子通道布局规范(Render Pass subpass layout specification) 内存栅格化命令(Memory Barrier Command)，是一个可以在命令缓冲区中显式调用的布局转换命令。应用举例，比如我们可以通过这个命令来同步多个复杂场景的内存访问。上面的方法一旦采用另外两种方法来实现布局转换，那就不能用内存栅格化命令来实现布局转换了。 通常，在渲染开始之前和渲染完成之后，需要进行图形布局转换以适应图像渲染。渲染开始前的第一次转换，会为GPU准备好适合的图像格式用于渲染；渲染完成后的最后一次转换，用于将图像呈现给显示设备。在这些情况下，我们需要将布局转换方式指定为渲染通道定义的一部分。在本章节我们将看到是如何具体做的。 一条布局转换命令，可能会触发也可能不会触发事实上GPU布局转换操作。比如，如果旧的布局格式未定义，且新的布局格式是优化的，那GPU就得什么都不做，除非程序已经安排GPU硬件采用优化的模式访问内存。这是因为图像内容处于未定义状态下，不能够通过转换它的格式来进行另存储。另外，如果旧的数据布局格式是一般的，朴素的，且有迹象表明需要图像数据进行另保存，那转换成优化布局时，可能会涉及到GPU的一些重新调整像素位置的工作，即GPU会进行布局转换操作。 即使你知道或者认为一条布局转换操作不会实际发生，但最好的实践方式还是在需要的地方进行添加布局转换操作，这是因为这样可以给驱动程序更多的信息，来帮助驱动软件确保你的应用程序能够在更多平台上执行正确。 Image Layout Transitions in the Samples 下面的样例采用的子通道定义(subpass definitions)和渲染通道定义(render pass definitions)来指定需要的图像格式的布局转换，而不是采用内存栅格化命令。 初始的渲染通道布局设置成了未定义，这表示我们不必关心初始的渲染通道布局格式，因为当渲染通道开始时，我们不用考虑图像缓存区中已经有什么样的数据且他们已经处于需要显示的状态了。在渲染通道开始时，我们只需要告诉驱动什么样的布局格式是有效的。在这种情况下，驱动不会进行任何转换，直到子通道开始或者渲染通道结束。 子通道布局格式被设置成对颜色缓冲区的优化布局，这就告诉驱动子通道渲染过程中，需要对子通道布局格式进行转换成优化的布局格式。对深度缓冲区的优化布局的设置过程是相似的。 最终渲染通道布局会告诉驱动要将布局转换成最优的布局格式用来显示。 Create the Render Pass现在我们应该知道了如何在某些场景中使用合适的图像布局格式，接下来就可以处理剩下的渲染通道。 Attachments 在本样例中，有两个附件(Attachment)，一个是颜色的，另一个是深度缓冲的：1234567891011121314151617181920VkAttachmentDescription attachments[2];attachments[0].format = info.format;attachments[0].samples = NUM_SAMPLES;attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;attachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;attachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;attachments[0].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;attachments[0].flags = 0;attachments[1].format = info.depth.format;attachments[1].samples = NUM_SAMPLES;attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;attachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;attachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;attachments[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;attachments[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;attachments[1].flags = 0; 在两个附件中，loadOp成员属性都设置为 CLEAR ，说明我们希望缓冲区能够在渲染通道实例( render pass instance)开始时被清空。 在颜色附件中，storeOp成员属性被设置为 STORE ，表示我们希望将渲染结构留在缓冲区中，这样才能够将图像呈献显示设备上。 在深度附件中，storeOp成员属性被设置为 DONT_CARE ，表示在渲染通道实例完成时不再需要缓冲区的内容，即缓冲区内容可清空可扔掉。 对于图像布局格式，我们需要将两个附件的初始格式设置为未定义布局格式(undefined layouts)，原因如同上面所说。 渲染子通道，即发生在初始化布局和最终布局期间，会将颜色附件转换成VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL状态，将深度附件转换成VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL。 对于颜色附件，我们需要指定最终布局为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR格式，该格式是一种用于渲染完成后的呈现操作的适合的格式。而对于深度附件，由于深度缓冲区在呈现操作时不会被用到，我们可以让深度缓冲区布局格式和渲染子通道相同。 Subpass 如果需要设置多个子通道，子通道的定义直接而又有趣。假定要实现环境光遮蔽或一些其它的特效，则可能需要对图形数据做一些预处理或后处理，那我们应当关注一下使用多个子通道。在这里，子通道的设定被用于在渲染过程中指定哪些附件有效，和指定渲染时需要用到的布局。1234567VkAttachmentReference color_reference = &#123;&#125;;color_reference.attachment = 0;color_reference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;VkAttachmentReference depth_reference = &#123;&#125;;depth_reference.attachment = 1;depth_reference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; attachment成员属性表示附件数组中对象附件索引，用于渲染渲染通道中。1234567891011VkSubpassDescription subpass = &#123;&#125;;subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;subpass.flags = 0;subpass.inputAttachmentCount = 0;subpass.pInputAttachments = NULL;subpass.colorAttachmentCount = 1;subpass.pColorAttachments = &amp;color_reference;subpass.pResolveAttachments = NULL;subpass.pDepthStencilAttachment = &amp;depth_reference;subpass.preserveAttachmentCount = 0;subpass.pPreserveAttachments = NULL; pipelineBindPoint成员属性表明是一个图形子通道还是一个计算子通道。当前属性值表示，只有图形子通道有效。 Render Pass 现在，我们已经拥有所有渲染通道需要定义的内容，可以创建渲染通道了：12345678910VkRenderPassCreateInfo rp_info = &#123;&#125;;rp_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;rp_info.pNext = NULL;rp_info.attachmentCount = 2;rp_info.pAttachments = attachments;rp_info.subpassCount = 1;rp_info.pSubpasses = &amp;subpass;rp_info.dependencyCount = 0;rp_info.pDependencies = NULL;res = vkCreateRenderPass(info.device, &amp;rp_info, NULL, &amp;info.render_pass); 在接下来的样例中，我们将使用渲染通道。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 4","slug":"Vulkan Samples Tutorial 4","date":"2017-04-24T03:00:00.000Z","updated":"2017-06-26T01:42:02.342Z","comments":true,"path":"2017/04/24/Vulkan Samples Tutorial 4/","link":"","permalink":"https://domacles.github.io/2017/04/24/Vulkan Samples Tutorial 4/","excerpt":"","text":"Descriptor Set Layouts and Pipeline Layouts Descriptors and Descriptor Sets Descriptor Set Layouts Pipeline Layouts Shader Referencing of Descriptors Create a Descriptor Set Descriptor Pool Allocate a Descriptor Set from the Pool Update the Descriptor Set Descriptor Set Layouts and Pipeline Layouts本章节代码在08-init_pipeline_layout.cpp中。 在之前的样例中，我们创建了Uniform Buffer，但我们还没有让shader来使用它。我们使用Descriptor来完成这一工作。 Descriptors and Descriptor Sets本段讲解什么是Descriptor，Descriptor是一种不透明的特殊着色器变量，作为一种间接的方式，着色器用它来存取缓冲区数据和图像资源。我们可以认为它是资源的指针(pointer)。Vulkan API中，支持在绘制操作过程中更改这些变量，如此着色器才能够为每次绘制使用不同的资源。 本样例作为一个简单的样例，我们只用了1个Uniform Buffer，但也有可能我们会创建两个Uniform Buffer，每一个都存放着不同的MVP矩阵，从而能够绘制不同场景。如果我们有两个Uniform Buffer，我们可以很轻松地改变Descriptor的指向，来切换MVP矩阵的使用。 Descriptor Set表示：该集合中的Descriptor指向的是同类型的资源，这些资源是使用相同的Layout Binding。 在本样例中我们没有用到材质(texture)，但可能我们会创建一个由两个Descriptor组成的集合，每个Descriptor引用着不同的材质，通过使用这个Descriptor Set，让这两种材质在绘制的过程中始终可用。命令缓冲区中存储的命令可以通过指定材质的索引来选择材质来使用。 注意，在本章节这里，我们并没有实际创建分类Descriptor Set，我们在本章节主要做的是“描述(describing)”Descriptor Set的配置属性。 为了能够设置Descriptor Set，我们需要使用Descriptor Set Layout。 Descriptor Set LayoutsDescriptor Set Layout用于设置集合中的内容。我们需要为每一个Descriptor集合绑定一个layout，就像下面这段代码：123456VkDescriptorSetLayoutBinding layout_binding = &#123;&#125;;layout_binding.binding = 0;layout_binding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;layout_binding.descriptorCount = 1;layout_binding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;layout_binding.pImmutableSamplers = NULL; 上面的代码我们实现了下面四个方面： 创建了一个Descriptor集合，并绑定到了0这个对象上，即将binding设置为0。 该Descriptor集合指向的是一个Uniform Buffer，即将descriptorType指定为我们需要的类型。 在这个Descriptor集合中，只有一个Descriptor对象，数量在descriptorCount上设置的。 最后，stageFlags指明了该Descriptor集合在顶点着色器执行阶段有效。 在绑定Descriptor对象之后，紧接着我们需要创建Descriptor Set Layout对象：123456789#define NUM_DESCRIPTOR_SETS 1VkDescriptorSetLayoutCreateInfo descriptor_layout = &#123;&#125;;descriptor_layout.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;descriptor_layout.pNext = NULL;descriptor_layout.bindingCount = 1;descriptor_layout.pBindings = &amp;layout_binding;info.desc_layout.resize(NUM_DESCRIPTOR_SETS);res = vkCreateDescriptorSetLayout(info.device, &amp;descriptor_layout, NULL, info.desc_layout.data()); Pipeline LayoutsPipeline Layout包含了一系列的Descriptor Set Layout。在定义Descriptor Set之后，我们就要完成Pipeline Layout的CreateInfo的填充了，在创建Pipeline Layout之后，就会创建我们之前定义的Descriptor了。 创建Pipeline Layout的代码：12345678910VkPipelineLayoutCreateInfo pPipelineLayoutCreateInfo = &#123;&#125;;pPipelineLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;pPipelineLayoutCreateInfo.pNext = NULL;pPipelineLayoutCreateInfo.pushConstantRangeCount = 0;pPipelineLayoutCreateInfo.pPushConstantRanges = NULL;pPipelineLayoutCreateInfo.setLayoutCount = NUM_DESCRIPTOR_SETS;pPipelineLayoutCreateInfo.pSetLayouts = info.desc_layout.data();res = vkCreatePipelineLayout(info.device, &amp;pPipelineLayoutCreateInfo, NULL, &amp;info.pipeline_layout); 完成上面的工作后，在接下来章节的内容，我们就可以用Pipeline Layout来创建图形管线（graphics pipeline）了。 Shader Referencing of Descriptors在着色器语言中，明确引用Descriptors是很有用的一个做法。 举个例子，在GLSL中：1layout (set=M, binding=N) uniform sampler2D variableNameArray[I]; 这一句告诉我们： M表示pSetLayouts管线成员中的第M个Descriptor Set Layout。 N表示M的pBingings的第N个Descriptor Set。 I表示Descriptor Set数组化的下标。 在顶点着色器中使用Uniform Buffer的Layout的代码如下：123layout (std140, binding = 0) uniform bufferVals &#123; mat4 mvp;&#125; myBufferVals; 这行代码表示Uniform Buffer中的内容映射到了myBufferVals结构体中；set=M没有指定，这里会默认M为0。std140是一个Uniform数据块打包的协议标准，你可以引用它，来将更多的数据塞到一个Uniform数据块中。如果你希望得到关于这个标准更多的信息，则点击这里来获取更多的信息。 Create a Descriptor Set本章节的代码在09-init_descriptor_set.cpp文件中。 回想一下上一章的内容，我们定义了descriptor set layout，但并没有立即创建descriptor set。descriptor set是用于告诉GPU如何组织Uniform BUffer的数据的。现在，我们就需要开始创建和初始化descriptor set。 Descriptor Pool就像命令缓冲区(Command Buffer)一样，descriptor set是从缓冲池(pool)中分配的。所以，我们第一步就是创建这个Descriptor Pool。因为我们样例只需要为一个uniform buffer创建一个descriptor set，可以使用下面的代码直接来搞：12345678910111213VkDescriptorPoolSize type_count[1];type_count[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;type_count[0].descriptorCount = 1;VkDescriptorPoolCreateInfo descriptor_pool = &#123;&#125;;descriptor_pool.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;descriptor_pool.pNext = NULL;descriptor_pool.maxSets = 1;descriptor_pool.poolSizeCount = 1;descriptor_pool.pPoolSizes = type_count;res = vkCreateDescriptorPool(info.device, &amp;descriptor_pool, NULL, &amp;info.desc_pool); Allocate a Descriptor Set from the Pool然后，我们需要从缓冲池中创建一个descriptor set。注意，这里我们需要提供在之前章节创建的descriptor set layout，这个layout描述了该descriptor set应当如何来创建。 下面是从缓冲池中创建descriptor set的代码：12345678VkDescriptorSetAllocateInfo alloc_info[1];alloc_info[0].sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;alloc_info[0].pNext = NULL;alloc_info[0].descriptorPool = info.desc_pool;alloc_info[0].descriptorSetCount = NUM_DESCRIPTOR_SETS;alloc_info[0].pSetLayouts = info.desc_layout.data();info.desc_set.resize(NUM_DESCRIPTOR_SETS);res = vkAllocateDescriptorSets(info.device, alloc_info, info.desc_set.data()); Update the Descriptor Set注意，事实上，我们还不能够随时随地使用uniform buffer的句柄来操作其中的数据。 在函数init_uniform_buffer()中，我们可以看到uniform buffer信息被存储到一个叫做info.uniform_data.buffer_info的VkDescriptorBufferInfo结构体对象中，该结构体对象在函数中被初始化。 info.uniform_data.buffer_info的结构体：12345typedef struct VkDescriptorBufferInfo &#123; VkBuffer buffer; VkDeviceSize offset; VkDeviceSize range;&#125; VkDescriptorBufferInfo; buffer成员包含着uniform buffer的句柄。 123456789101112VkWriteDescriptorSet writes[1];writes[0] = &#123;&#125;;writes[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;writes[0].pNext = NULL;writes[0].dstSet = info.desc_set[0];writes[0].descriptorCount = 1;writes[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;writes[0].pBufferInfo = &amp;info.uniform_data.buffer_info;writes[0].dstArrayElement = 0;writes[0].dstBinding = 0;vkUpdateDescriptorSets(info.device, 1, writes, 0, NULL); 上面的步骤，实质上是将VkDescriptorBufferInfo复制到descriptor上，如同device内存一样。 info的buffer——info包含着uniform buffer的句柄，也有uniform buffer中数据的地址偏移(offset)和大小(size)。在本样例中，因为uniform buffer只包含这MVP转换矩阵，所以这里uniform data的数据偏移为0，数据大小为MVP矩阵的大小。 descriptor的二进制实现细节可能对于不同设备有所不同，且对于我们是不透明的。这就是为什么我们要使用Vulkan驱动中的函数来操作descriptor对象，而不是自己直接通过内存映射和内存读写的原因。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 3","slug":"Vulkan Samples Tutorial 3","date":"2017-04-10T16:12:13.000Z","updated":"2017-06-26T01:42:02.341Z","comments":true,"path":"2017/04/11/Vulkan Samples Tutorial 3/","link":"","permalink":"https://domacles.github.io/2017/04/11/Vulkan Samples Tutorial 3/","excerpt":"","text":"Depth Buffer Create a Depth Buffer Create the Depth Buffer Image Object Allocate the Memory for the Depth Buffer Bind the Memory to the Depth Buffer Create the Image View Uniform Buffer Create a Uniform Buffer Setting up the Uniform Data Creating the Uniform Buffer Object Allocating the Uniform Buffer Memory Mapping and Setting the Uniform Buffer Memory Depth Buffer和Uniform Buffer在OpenGL也有对应的概念，可以参考OpenGL的讲述来理解这两个缓冲区的作用。 Depth Buffer本章节代码在06-init_depth_buffer.cpp文件中。 Create a Depth Buffer深度缓冲区（Depth Buffer）可以可选的，在最后的样例工程中要渲染3D立方体，就必须使用深度缓冲区。深度缓冲区对于每个Swapchain的Image都是可以复用的，因此，深度缓冲区应当只使用一个，即便Swapchain中有很多image对象。 不同于vkCreateSwapchainKHR()，当Swapchain的每个Image对象创建时，你需要自己去创建和分配深度缓冲区给Image： 创建使用深度缓冲区Image对象 深度缓冲区所在设备上分配内存 把申请的内存绑定到Image对象上 创建使用深度缓冲区的Image View 以上步骤可以使用下图表示： Create the Depth Buffer Image Object与之前一些使用CreateInfo创建对象的过程相同，创建使用深度缓冲区的Image对象的代码如下：123456789101112131415161718mage_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;image_info.pNext = NULL;image_info.imageType = VK_IMAGE_TYPE_2D;image_info.format = VK_FORMAT_D16_UNORM;image_info.extent.width = info.width;image_info.extent.height = info.height;image_info.extent.depth = 1;image_info.mipLevels = 1;image_info.arrayLayers = 1;image_info.samples = NUM_SAMPLES;image_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;image_info.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;image_info.queueFamilyIndexCount = 0;image_info.pQueueFamilyIndices = NULL;image_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;image_info.flags = 0;vkCreateImage(info.device, &amp;image_info, NULL, &amp;info.depth.image); 上面这份代码仅仅为Image创建了一个对象，还并没有为它申请深度缓冲区内存。但在创建时，你需要设置足够的信息用于创建匹配窗口大小的深度缓冲区。 Allocate the Memory for the Depth Buffer在申请分配深度缓冲区内存之前，我们需要知道要申请的内存大小。但由于GPU硬件上的内存有对齐约束，而这些约束不同设备之间可能有所不同，因此，我们需要通过Vulkan的API来查询我们需要的内存大小、对齐方式、内存类型等信息：1vkGetImageMemoryRequirements(info.device, info.depth.image, &amp;mem_reqs); 然后我们需要用获取到的VkMemoryRequirements对象，来填充VkMemoryAllocateInfo这个Info对象：1234567VkMemoryAllocateInfo mem_alloc = &#123;&#125;;mem_alloc.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;mem_alloc.pNext = NULL;mem_alloc.allocationSize = mem_reqs.size;pass = memory_type_from_properties(info, mem_reqs.memoryTypeBits, 0, /* No Requirements */ &amp;mem_alloc.memoryTypeIndex); memory_type_from_properties()是一个用于确定适合的内存指针类型的函数。最后，使用下面的代码来进行分配内存：1vkAllocateMemory(info.device, &amp;mem_alloc, NULL, &amp;info.depth.mem); Bind the Memory to the Depth Buffer在拥有一个Image对象且申请到了设备上的深度缓冲区内存之后，就可以将缓冲区内存帮到Image对象上：1vkBindImageMemory(info.device, info.depth.image, info.depth.mem, 0); Create the Image View接下来就是按照自己的需要，设置ViewCreateInfo对象，然后与之前相同的流程，使用vkCreateImageView()函数创建对象：123456789101112131415161718VkImageViewCreateInfo view_info = &#123;&#125;;view_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;view_info.pNext = NULL;view_info.image = info.depth.image;view_info.format = VK_FORMAT_D16_UNORM;view_info.components.r = VK_COMPONENT_SWIZZLE_R;view_info.components.g = VK_COMPONENT_SWIZZLE_G;view_info.components.b = VK_COMPONENT_SWIZZLE_B;view_info.components.a = VK_COMPONENT_SWIZZLE_A;view_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;view_info.subresourceRange.baseMipLevel = 0;view_info.subresourceRange.levelCount = 1;view_info.subresourceRange.baseArrayLayer = 0;view_info.subresourceRange.layerCount = 1;view_info.viewType = VK_IMAGE_VIEW_TYPE_2D;view_info.flags = 0;res = vkCreateImageView(info.device, &amp;view_info, NULL, &amp;info.depth.view); Uniform Buffer本章节代码在07-init_uniform_buffer.cpp文件中。 Create a Uniform BufferUniform Buffer是用来为着色器(shaders)程序提供常量数据的只读缓冲区。与深度缓冲区相同，你需要自己申请内存并填充它。 Setting up the Uniform Data本章样例中，我们使用Uniform Buffer将MVP(Model-View-Projection)矩阵送到着色器中，如此着色器才能对每一个顶点进行转换。 下面是创建MVP矩阵的代码：1234567891011121314info.Projection = glm::perspective(glm::radians(45.0f), 1.0f, 0.1f, 100.0f);info.View = glm::lookAt( glm::vec3(-5, 3, -10), // Camera is at (-5,3,-10), in World Space glm::vec3(0, 0, 0), // and looks at the origin glm::vec3(0, -1, 0) // Head is up (set to 0,-1,0 to look upside-down) );info.Model = glm::mat4(1.0f);// Vulkan clip space has inverted Y and half Z.info.Clip = glm::mat4(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.5f, 1.0f);info.MVP = info.Clip * info.Projection * info.View * info.Model; 注意，glm库在这里用来简化代码，实际上矩阵运算需要自己写；info.MVP是一个4*4的矩阵。 Creating the Uniform Buffer Object创建Uniform缓冲区的过程与之前的深度缓冲区(Depth Buffer)基本一致，只有在usage属性上有所不同：1234567891011VkBufferCreateInfo buf_info = &#123;&#125;;buf_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;buf_info.pNext = NULL;buf_info.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;buf_info.size = sizeof(info.MVP);buf_info.queueFamilyIndexCount = 0;buf_info.pQueueFamilyIndices = NULL;buf_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;buf_info.flags = 0;res = vkCreateBuffer(info.device, &amp;buf_info, NULL, &amp;info.uniform_data.buf);assert(res == VK_SUCCESS); Allocating the Uniform Buffer Memory与为深度缓冲区申请内存使的过程一样，先使用API计算出需要的内存大小，然后使用memory_type_from_properties()进行分配：1234567891011121314151617VkMemoryRequirements mem_reqs;vkGetBufferMemoryRequirements(info.device, info.uniform_data.buf, &amp;mem_reqs);VkMemoryAllocateInfo alloc_info = &#123;&#125;;alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;alloc_info.pNext = NULL;alloc_info.memoryTypeIndex = 0;alloc_info.allocationSize = mem_reqs.size;pass = memory_type_from_properties(info, mem_reqs.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &amp;alloc_info.memoryTypeIndex);res = vkAllocateMemory(info.device, &amp;alloc_info, NULL, &amp;(info.uniform_data.mem)); 使用VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT标记，表示分配的这块内存对CPU(Host)是可以读取的。 使用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT标记，表示Host的内存与设备是相互可见的，并不需要刷新内存缓存。这种做法对程序是一种简化，如此便不需要调用vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges来确保内存的数据对GPU可见。 Mapping and Setting the Uniform Buffer Memory在使用深度缓冲区内存时，我们不需要去初始化它，这是因为GPU会对它的读写进行适当的处理。但在使用Uniform Buffer时，我们必须用我们要传给着色器的数据来填充它。为了让CPU能够对Uniform Buffer的内存进行读写，我们需要进行如下映射：12res = vkMapMemory(info.device, info.uniform_data.mem, 0, mem_reqs.size, 0, (void **)&amp;pData); 然后将数据复制到Uniform BUffer上，再解除映射：12memcpy(pData, &amp;info.MVP, sizeof(info.MVP));vkUnmapMemory(info.device, info.uniform_data.mem); 由于这块缓冲区在内存上，进行内存映射会由于页表替换等导致映射无效，因此需要立即解除映射。 最后，你只需要创建一个Buffer对象来关联内存：12res = vkBindBufferMemory(info.device, info.uniform_data.buf, info.uniform_data.mem, 0); 然后，Unform Buffer就算可以使用了。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 2","slug":"Vulkan Samples Tutorial 2","date":"2017-04-07T02:18:23.000Z","updated":"2017-06-26T01:42:02.340Z","comments":true,"path":"2017/04/07/Vulkan Samples Tutorial 2/","link":"","permalink":"https://domacles.github.io/2017/04/07/Vulkan Samples Tutorial 2/","excerpt":"","text":"Swapchain Vulkan and the Windowing System Revisiting Instance and Device Extensions Queue Family and Present Swapchain Create Info Different Queue Families for Graphics and Present Create Swapchain Create Image Views Swapchain本章节的代码在文件 05-init_swapchain.cpp 中。 Swapchain 即帧缓存机制，它是使用了一系列的帧缓存区用来保证帧刷新率稳定的技术。帧缓存区通常放在显卡内存中，但也可以放在内存中。Swapchain 需要通过图形API开启并使用，未使用 Swapchain 会导致刷新不一致等问题。每个 swap chain 至少有两个缓冲区，一个作为屏幕显示缓冲区，另外一个作为后台缓冲区。两个缓冲区一般被称为 presentation 和 swapping 。 本小节讲述了如何创建swapchain。首先需要做的就是创建用来渲染的图形缓冲区(image buffers)。 上图展示了Swapchain与其他各部分之间的联系，图中的其他部分与下面所讲的内容关系也十分密切，需要注意。 Vulkan and the Windowing System与其他的图形API相似的是，Vulkan将有关于窗口系统的API与图形核心API分离开了。在Vulkan中，窗口系统的细节是通过 WSI 扩展(Window System Integration extensions)呈献给开发者的。我们可以从Vulkan的设计规范中找到与WSI相关的扩展的文档。在LunarG LunarXchange website和Khronos Vulkan Registry这两个地方可以找到Vulkan API规范和发布的扩展的使用规范。 WSI扩展包含了对多种平台的支持。使用WSI扩展是通过定义下面几个宏定义来实现的： VK_USE_PLATFORM_ANDROID_KHR - Android VK_USE_PLATFORM_MIR_KHR - Mir VK_USE_PLATFORM_WAYLAND_KHR - Wayland VK_USE_PLATFORM_WIN32_KHR - Microsoft Windows VK_USE_PLATFORM_XCB_KHR - X Window System, using the XCB library (Apples) VK_USE_PLATFORM_XLIB_KHR - X Window System, using the Xlib library (Apples)KHR 命名后缀表示扩展是按照 Khronos 组织的规范实现的。 Surface Abstraction Vulkan 使用 VkSurfaceKHR 对象来作为本地平台显示层或者窗口的抽象化对象。该对象是在VK_KHR_surface扩展中定义的。WSI扩展的作用是创建，操纵或者销毁显示层对象(surface objects)。 Revisiting Instance and Device Extensions在前面的几个章节中，我们推迟了扩展的设置，现在需要我们回顾之前 Instance 和 Device 的扩展设置，从而能够让我们学会如何启动WSI扩展。 Instance Extensions 使用WSI扩展的首要步骤是，启动表示层扩展(surface extension)。查看本章样例中使用的init_instance_extension_names()函数的实现代码，我们发现样例是将VK_KHR_SURFACE_EXTENSION_NAME添加到Instance扩展列表：12345678910void init_instance_extension_names(struct sample_info &amp;info) &#123; info.instance_extension_names.push_back(VK_KHR_SURFACE_EXTENSION_NAME);#ifdef __ANDROID__ info.instance_extension_names.push_back(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME);#elif defined(_WIN32) info.instance_extension_names.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME);#else info.instance_extension_names.push_back(VK_KHR_XCB_SURFACE_EXTENSION_NAME);#endif&#125; 该函数不仅添加了通用Surface扩展，还针对其他平台添加对应的扩展。比如，针对Win32平台会将VK_KHR_WIN32_SURFACE_EXTENSION_NAME添加到Instance扩展列表中。 这些扩展将会在Instance创建时加载，加载的实现代码可以在init_instance()中进行查看。 注意：在init_instance()中我们看到instance_extension_names列表是通过传指针数组将内容的地址设置到ppEnabledExtensionNames上的。 Device Extensions Swapchain 是一个图像缓存的列表，GPU向其中输入图像，该列表的图像会被呈现到显示输出设备。每当GPU向其中写入图像数据，device-level 扩展就会开始处理 Swapchain。所以，在进行 device 初始化之前需要指定device扩展，在init_device_extension_names()函数中，我们看到使用的device扩展是VK_KHR_SWAPCHAIN_EXTENSION_NAME:123void init_device_extension_names(struct sample_info &amp;info) &#123; info.device_extension_names.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);&#125; 这些扩展将在创建Device时进行加载，加载的实现代码可以在init_device()中进行查看，与init_instance()类似。 Instance &amp; Device Extensions recap： 本节样例使用 init_instance_extension_names() 函数来加载常用的surface扩展，并将平台相关的对应扩展也加到了instance扩展列表中了。 本节样例使用 init_device_extension_names() 函数来加载一个Swapchain设备扩展。 Queue Family and PresentPresent 操作，就是使一个Swapchain图像缓冲放到物理显示设备上的操作。当我们的应用程序需要显示图像，那就需要向某一个GPU设备队列发送一个呈现(Present)请求（具体方法是调用vkQueuePresentKHR()实现的）但接受请求的GPU队列需要能够支持present请求，或者支持graphics和present请求。下面的代码就展示了如何找到一个支持graphics和present操作的GPU队列：1234567891011121314151617181920212223242526272829303132333435363738394041424344// Iterate over each queue to learn whether it supports presenting:VkBool32 *pSupportsPresent = (VkBool32 *)malloc(info.queue_family_count * sizeof(VkBool32));for (uint32_t i = 0; i &lt; info.queue_family_count; i++) &#123; vkGetPhysicalDeviceSurfaceSupportKHR(info.gpus[0], i, info.surface, &amp;pSupportsPresent[i]);&#125;// Search for a graphics and a present queue in the array of queue// families, try to find one that supports bothinfo.graphics_queue_family_index = UINT32_MAX;info.present_queue_family_index = UINT32_MAX;for (uint32_t i = 0; i &lt; info.queue_family_count; ++i) &#123; if ((info.queue_props[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) != 0) &#123; if (info.graphics_queue_family_index == UINT32_MAX) info.graphics_queue_family_index = i; if (pSupportsPresent[i] == VK_TRUE) &#123; info.graphics_queue_family_index = i; info.present_queue_family_index = i; break; &#125; &#125;&#125;if (info.present_queue_family_index == UINT32_MAX) &#123; // If didn&apos;t find a queue that supports both graphics and present, then // find a separate present queue. for (size_t i = 0; i &lt; info.queue_family_count; ++i) if (pSupportsPresent[i] == VK_TRUE) &#123; info.present_queue_family_index = i; break; &#125;&#125;free(pSupportsPresent);// Generate error if could not find queues that support graphics // and present if (info.graphics_queue_family_index == UINT32_MAX || info.present_queue_family_index == UINT32_MAX) &#123; std::cout &lt;&lt; &quot;Could not find a queues for graphics and &quot; &quot;present\\n&quot;; exit(-1); &#125; 上面这份代码，再次使用在这之前便已获取的变量info.queue_family_count，通过调用vkGetPhysicalDeviceSurfaceSupportKHR()函数来获取每一个queue family的是否支持surface的标志。然后遍历所有的queue family，来寻找同时支持present和graphics的GPU队列族。最后，如果发现没有找到同时支持present和graphics的GPU队列族，则去寻找一个支持present的GPU队列族，将present和graphics功能分到两个GPU queue family上。接下来的代码，会从graphics_queue_family_index获取执行图形命令的队列编号，从present_queue_family_index获取执行呈现操作的队列编号。 free()上面的if语句实际上有些多余，但这里如此写是为了针对没有都支持graphics和present的GPU队列的情况做说明的。 最后，如果发现graphics或者present功能找不齐，该代码会结束运行。 Swapchain Create Info接下来更多的内容是设置Swapchain的Create Info结构体：1234567891011121314151617181920typedef struct VkSwapchainCreateInfoKHR &#123; VkStructureType sType; const void* pNext; VkSwapchainCreateFlagsKHR flags; VkSurfaceKHR surface; uint32_t minImageCount; VkFormat imageFormat; VkColorSpaceKHR imageColorSpace; VkExtent2D imageExtent; uint32_t imageArrayLayers; VkImageUsageFlags imageUsage; VkSharingMode imageSharingMode; uint32_t queueFamilyIndexCount; const uint32_t* pQueueFamilyIndices; VkSurfaceTransformFlagBitsKHR preTransform; VkCompositeAlphaFlagBitsKHR compositeAlpha; VkPresentModeKHR presentMode; VkBool32 clipped; VkSwapchainKHR oldSwapchain;&#125; VkSwapchainCreateInfoKHR; 下面的几段文章，讲述了创建设置Swapchain前后的全部过程。 Creating a Surface 要在instance和device中使用WSI扩展，首先需要创建一个VkSurface对象，然后才能用它来进行Swapchain的创建。在05-init_swapchain.cpp文件的main函数开始的地方，我们可以看到针对本地平台的Surface的创建过程：12345678#ifdef _WIN32 VkWin32SurfaceCreateInfoKHR createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; createInfo.pNext = NULL; createInfo.hinstance = info.connection; createInfo.hwnd = info.window; res = vkCreateWin32SurfaceKHR(info.inst, &amp;createInfo, NULL, &amp;info.surface);#endif 本段代码中的info.connection和info.window分别在init_connection()和init_window()函数中针对本地平台进行了创建和初始化。在Vulkan中，通过vkCreateWin32SurfaceKHR()函数创建的VkSurfaceKHR Surface对象表示一个用于处理平台窗口的对象。 注意：init_connection()和init_window()是平台相关的，这两个函数为我们连接显示设备创建窗口程序屏蔽了很多细节。 接下来我们需要将创建的info.surface对象设置到Swapchain Create Info结构体中：1234VkSwapchainCreateInfoKHR swapchain_ci = &#123;&#125;;swapchain_ci.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;swapchain_ci.pNext = NULL;swapchain_ci.surface = info.surface; Device Surface Formats 当你创建Swapchain时，你需要指定surface的格式(Formats)。Format 在这里表示VkFormat枚举器中描述的像素格式，比如：VK_FORMAT_B8G8R8A8_UNORM格式就是一种Device SUrface Format。 本章节接下来的一段代码就是获取一个VkSurfaceFormatKHR结构体列表，该列表保存着显示设备支持的VkFormat格式以及其他信息。本样例代码不关心用什么格式，于是便采用了第一个可用格式作为将要使用的格式。 然后，我们在本章节代码的后面部分可以看到VkFormat被设置到Swapchain create info结构体中：1swapchain_ci.imageFormat = info.format; Surface Capabilities 获取到Formats之后，我们需要获取到Surface Capabilities和Present Modes来填充Swapchain的create info结构体，在本章节代码中，我们看到调用了vkGetPhysicalDeviceSurfaceCapabilitiesKHR()和 vkGetPhysicalDeviceSurfacePresentModesKHR()两个函数分别获取Surface Capabilities和Present Modes，之后的部分我们可以看到这两个对象中的信息被设置到了Swapchain create info结构体中：1234567uint32_t desiredNumberOfSwapChainImages = surfCapabilities.minImageCount;swapchain_ci.minImageCount = desiredNumberOfSwapChainImages;swapchain_ci.imageExtent.width = swapChainExtent.width;swapchain_ci.imageExtent.height = swapChainExtent.height;swapchain_ci.preTransform = preTransform;swapchain_ci.presentMode = swapchainPresentMode; minImageCount属性，用于设置缓冲区使用策略：双缓冲区、三缓冲区等。本章节代码中是从使用vkGetPhysicalDeviceSurfaceCapabilitiesKHR()函数获取到到的surfCapabilities对象中查到Device支持的图像缓冲区的最小个数。 Different Queue Families for Graphics and Present在本章之前的代码中，我们找到了有graphics和present功能的GPU队列，如果他们并不是同一个队列，我们需要做一些其他设置，让它们能够共享图像缓冲：123456789101112131415swapchain_ci.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;swapchain_ci.queueFamilyIndexCount = 0;swapchain_ci.pQueueFamilyIndices = NULL;uint32_t queueFamilyIndices[2] = &#123; (uint32_t)info.graphics_queue_family_index, (uint32_t)info.present_queue_family_index&#125;;if (info.graphics_queue_family_index != info.present_queue_family_index) &#123; // If the graphics and present queues are from different queue families, // we either have to explicitly transfer ownership of images between the // queues, or we have to create the swapchain with imageSharingMode // as VK_SHARING_MODE_CONCURRENT swapchain_ci.imageSharingMode = VK_SHARING_MODE_CONCURRENT; swapchain_ci.queueFamilyIndexCount = 2; swapchain_ci.pQueueFamilyIndices = queueFamilyIndices;&#125; 上面的代码是创建Swapchain常用的做法。本章节其余代码是设置Swapchain Create Info结构体的其他属性，可以参考用于将来自己的程序实现。 Create Swapchain在Swapchain Create Info结构体设置完成后，我们使用下面这一句代码创建Swapchain：1res = vkCreateSwapchainKHR(info.device, &amp;swapchain_ci, NULL, &amp;info.swap_chain); vkCreateSwapchainKHR()函数创建了许多图像缓冲区用于建立Swapchain。 在程序进行时，我们可能需要获取每个Swapchain上的图像缓冲区，我们应该用下面这段符合之前获取格式的代码：12345678910res = vkGetSwapchainImagesKHR(info.device, info.swap_chain, &amp;info.swapchainImageCount, NULL); assert(res == VK_SUCCESS); VkImage *swapchainImages = (VkImage *)malloc(info.swapchainImageCount * sizeof(VkImage)); assert(swapchainImages); res = vkGetSwapchainImagesKHR(info.device, info.swap_chain, &amp;info.swapchainImageCount, swapchainImages); assert(res == VK_SUCCESS); 来获取Swapchain Images的列表，然后向其中输入数据，在之后通知GPU渲染他们。 Create Image ViewsVkImageView中存储着图像数据的信息，如：图像内存的排列格式，用于1D，2D还是3D，也用于记录图像的格式，颜色组成的顺序以及插件的信息。在本章节代码中，我们可以看到最后的for循环中使用vkCreateImageView创建了针对于每个Swapchain的image缓冲区的view缓冲区，存于info中。 在创建完image view之后，算是完成了创建Swapchain的过程，在后面的章节中我们将使用info中的iamge view。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Vulkan Samples Tutorial 1","slug":"Vulkan Samples Tutorial 1","date":"2017-03-19T11:42:46.000Z","updated":"2017-06-26T01:42:02.336Z","comments":true,"path":"2017/03/19/Vulkan Samples Tutorial 1/","link":"","permalink":"https://domacles.github.io/2017/03/19/Vulkan Samples Tutorial 1/","excerpt":"","text":"Introduction Instance Vulkan Instance vkCreateInstance VkInstanceCreateInfo VkApplicationInfo Back to the Code Enumerate Devices vkEnumeratePhysicalDevices The Samples_info Structure Device Device Queues and Queue Families Creating the Logical Device Command Buffer Basic Command Buffer Operation Creating the Command Buffer Using Command Buffers 本文会通过几个章节告诉你们如何一步一步地创建一个简单的Vulkan程序，每一章节对应着Vulkan程序运行的每一部分过程。 相关代码在下载的Vulkan SDK中的Samples文件夹中，在使用cmake构建工程之前，请先阅读Documentation/vulkan_samples.html文件来了解如何构建时所需要的配置。在此不再赘述。 本文的最终目标是初步理解Vulkan API的使用并创建出显示一个立方体的程序，效果如下： Introduction每个章节的代码使用下面的格式，目的是为了能够使大家能够了解该章节的主题。1234567891011121314151617init_instance(info, sample_title);init_enumerate_device(info);init_window_size(info, 500, 500);init_connection(info);init_window(info);init_swapchain_extension(info);init_device(info);.../* VULKAN_KEY_START */... code of interest/* VULKAN_KEY_END */...destroy_device(info);destroy_window(info);destroy_instance(info); Instance本章节的代码在01-init_instance.cpp文件中。 Vulkan InstanceVulkan API使用vkInstance来存储程序的预先设置的状态(per-application state)，所有的应用程序在使用Vulkan API进行操作之前都必须需要创建Vulkan Instance。 Vulkan程序的基础结构如下： 上图告诉我们：Vulkan程序会被连接到一个Vulkan库上，这个库被称为Loader。应用程序需要通过创建Vulkan Instance来对loader进行初始化。loader之后会对更底层的显卡驱动进行加载和初始化。 上图中，有许多Layers被loader加载，这些Layer通常被用作程序校验的，例如对程序的正常运行进行错误检查。在Vulkan中，设备驱动程序变得比在使用OpenGL时更加轻量级化，这是因为在OpenGL中的一些如校验功能等被Layers所代替。Layers是可配置的，也可以在每次创建程序时选择加载。Vulkan Layers不再本文的讨论范围之内。进一步了解请到LunarXchange的Layers章节进行了解和学习。 vkCreateInstance在01-init_instance.cpp文件中，我们找到下面这一句：1res = vkCreateInstance(&amp;inst_info, NULL, &amp;inst); vkCreateInstance函数的原型如下：1234VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance); 在vulkan.h头文件中查看该函数定义，我们可以得知： vkResult是一个枚举类型，查看其定义可知，它定义了一系列vulkan的状态，如：VK_SUCCESS，VK_NOT_READY，VK_TIMEOUT,VK_EVENT_SET ，VK_EVENT_RESET，VK_INCOMPLETE等。我们可以通过该返回值来判断我们进行的vulkan操作是否得到我们需要的状态，并针对该状态进行处理。 VkInstanceCreateInfo是一个结构体类型，查看其定义可知，该结构体中用来存储创建Vulkan Instance所必须的一些设置。 VkAllocationCallbacks也是一个结构体类型，但通过查看其定义，它其中存放的是一些函数指针(不支持lambda表达式，但我们可以使用std::function::target函数获取lambda表达式的函数指针，具体用法可以参照cppreference.com - target的使用方法)，这些函数作为回调函数供vkCreateinstance函数使用。该函数用于实现应用程序自己的内存分配策略，如果没有设置，则vulkan会执行其默认的内存分配策略。在本小节的01-init_instance.cpp文件中并没有使用该特性，因此调用位置设置的值为NULL。 VkInstance是一个Vulkan Instance类型，该参数是一个返回值，当Vulkan Instance创建成功后该返回值有值。由于该实例并不是一个我们可见的自定义类型，当使用它时不应当去尝试对它解除引用(de-reference)。 注意：vkCreateInstance函数为我们展示了许多Vulkan函数的定义方法，返回值为操作完成的状态，参数中有输入的设置变量，数据变量，也有输出的实例。 VkInstanceCreateInfo接下来我们查看一下VkInstanceCreateInfo类型的定义：12345678910typedef struct VkInstanceCreateInfo &#123; VkStructureType sType; const void* pNext; VkInstanceCreateFlags flags; const VkApplicationInfo* pApplicationInfo; uint32_t enabledLayerCount; const char* const* ppEnabledLayerNames; uint32_t enabledExtensionCount; const char* const* ppEnabledExtensionNames;&#125; VkInstanceCreateInfo; 该结构体的前两个属性，会在许多Vulkan CreateInfo中进行定义。 sType是一个枚举类型，表明当前CreateInfo是个什么类型的结构体，虽然看似与VkInstanceCreateInfo的命名作用重合，在CreateInfo结构体声明自己的类型有两个原因： 驱动程序(driver)，校验插件(validation layer)或者其他定义的结构可以方便地进行类型检验，如果不符合期望类型则会停止执行下面的操作。 该结构体可以被一个无类型指针(void *)传递到一个使用未定义类型指针的函数中，在该函数中进行类型转换后可以方便进行类型检验。比如，一个驱动程序支持一个扩展来创建vulkan实例，该驱动程序就会沿着pNext指向的CreateInfo链表查找指定类型的结构体，以满足插件的需要。 pNext是一个无类型指针，它有时候会被用于指向一些记录着特定信息的结构体，这些结构体是某些插件所需要的。该值可能会很少被用到。 flags这是一个标记变量(……不知是干什么的)。 pApplicationInfo变量存放的是VkApplicationInfo类型结构体的指针，该类型会在下面讲到。 enabledLayerCount加载的插件(layer)的数量，如果没有加载，则设置为0即可。 ppEnabledLayerNames加载的插件的名称的数组的指针，就是将插件列表的首地址设置到这个结构体中。 enabledExtensionCount使用的扩展(extension)的数量，如果没有使用，则设置为0即可。 ppEnabledExtensionNames同样，这里是将扩展的列表的首地址设置到这个结构体中。 VkApplicationInfo接下来我们看看用于提供Vulkan程序基本信息的VkApplicationInfo类型的定义：123456789typedef struct VkApplicationInfo &#123; VkStructureType sType; const void* pNext; const char* pApplicationName; uint32_t applicationVersion; const char* pEngineName; uint32_t engineVersion; uint32_t apiVersion;&#125; VkApplicationInfo; sType和pNext同上面的VkInstanceCreateInfo中的作用相同，记录该结构体的类型以及构成结构体链。 pApplicationName, applicationVersion, pEngineName, engineVersion这四个属性值是可以进行自由设置，有一些工具，加载器，插件和驱动程序(tools, loaders, layers, or drivers)会通过这几个变量提供一些Debug信息或者其他报告信息，程序运行时，驱动程序可以根据这些设置进行区别化地运行。 apiVersion设置Vulkan API的版本号，暂且设置为VK_API_VERSION_1_0就好。 Back to the Code在/* VULKAN_KEY_START */和/* VULKAN_KEY_END */之间的代码，做了下面几件事情： 初始化VkApplicationInfo结构体app_info和VkInstanceCreateInfo结构体inst_info； 使用vkCreateInstance()函数创建Vulkan Instance，即inst； 对VkResult类型的返回值res变量进行检查，如果发现创建失败则终止程序； 使用vkDestroyInstance()对inst进行释放。 Enumerate Devices本章节的代码在02-enumerate_devices.cpp中。 在你创建Vulkan Instance之后，Loader就会知道有多少个物理显示设备可用，而你的应用程序则需要调用Vulkan API来获取设备列表。在获取设备可用数量之后，便可以进行区别化的逻辑运算。 Vulkan Instance依赖着vkPhysicalDevice(不明白这里的这个图想具体告诉我们什么)： Getting Lists of Objects from Vulkan 获取对象列表在Vulkan操作中是非常常见的行为，Vulkan API对这种需求的策略也是一致的：返回值为对象数量和对象列表指针首地址。在使用获取对象列表的API 时，我们需要按照下面的步骤进行： 调用获取对象列表的API，传入的参数为一个整数型变量的地址和NULL指针，前者用于第一次获取对象列表的对象数量，后者告诉API本次不获取对象列表。 API会将对象列表的数量填到传入的整形变量地址所指向的整形变量上。 应用程序需要根据API给出的对象列表数量申请足够多的内存。 应用程序再次调用获取对象列表的API，传入的参数为一个整数型变量的地址，和上一步申请内存的地址，这一次API会将对象列表存储到传入的指针所指向的位置上。该方法是使用获取对象列表API的标准流程。 vkEnumeratePhysicalDevicesvkEnumeratePhysicalDevices函数，就是用来获取显示设备列表的API，在02-enumerate_devices.cpp文件中，我们可以看到如下使用方法：12345678uint32_t gpu_count = 1;// Get the number of devices (GPUs) available.VkResult U_ASSERT_ONLY res = vkEnumeratePhysicalDevices(info.inst, &amp;gpu_count, NULL);assert(gpu_count);// Allocate space and get the list of devices.info.gpus.resize(gpu_count);res = vkEnumeratePhysicalDevices(info.inst, &amp;gpu_count, info.gpus.data());assert(!res &amp;&amp; gpu_count &gt;= 1); 在这里的使用方法，如上面步骤一样。 注意：info.gpus 变量的声明为 std::vector&lt;VkPhysicalDevice&gt; gpus，是一个VkPhysicalDevice类型的vector数组。 The Samples_info Structure在文件02-enumerate_devices.cpp中，我们看到这样的：123struct sample_info info = &#123;&#125;;init_global_layer_properties(info);init_instance(info, &quot;vulkansamples_enumerate&quot;); 在这里，所有的样例源代码文件中，会声明sample_info来存储一些必须的类型，并通过调用init_instance(info, &quot;vulkansamples_enumerate&quot;)来简化代码，方便查看。该函数实现了上一小节中初始化的代码。sample_info中的inst会被用来放到vkEnumeratePhysicalDevices()使用。 Device本章节的代码在03-init_device.cpp中。 继枚举可用物理设备之后，我们需要创建虚拟设备对象VkDevice(logical device object)来与物理设备相对应。虚拟设备对象是直接向硬件发送图形命令的关键对象。 为了简化流程，本示例代码仅从获取到的设备列表中使用第一个设备来进行创建VkDevice。从上一章可以看到，代码中会声明一个sample_info类型的对象info，该对象会存储Vulkan中用到的一些对象，其中info.gpus存储的就是我们在上一章获取的物理设备对象列表，我们取用info.gpus[0]来创建并初始化VkDevice对象。 为了实现创建初始化VkDevice或其他的虚拟设备对象，我们需要进行下面的步骤。 Device Queues and Queue Families与其他的图形API(这里难道是在黑DX，OpenGL??)相比，Vulkan会将设备对象开放给程序开发者，程序开发者可以获取这些队列并决定何时使用或者使用什么类型的队列。 在这里，Vulkan命令队列是一个用于向硬件发送命令的抽象数据结构。在之后的代码中，我们可以看到如何使用Vulkan程序建立一个命令缓冲区并将缓冲区中的命令提交到另外一个被用于GPU硬件的异步操作队列中。 Vulkan会根据队列(Device Queues)里存放的对象类型来安排队列在队列群(Queue Families)中的位置。当我们需要查询一个队列的类型和属性，我们需要从物理设备中查询 QueueFamilyProperties。 接下来我们看一看VkQueueFamilyProperties的类型定义：12345678910111213typedef struct VkQueueFamilyProperties &#123; VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity;&#125; VkQueueFamilyProperties;typedef enum VkQueueFlagBits &#123; VK_QUEUE_GRAPHICS_BIT = 0x00000001, VK_QUEUE_COMPUTE_BIT = 0x00000002, VK_QUEUE_TRANSFER_BIT = 0x00000004, VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,&#125; VkQueueFlagBits; 获取VkQueueFamilyProperties同上一章讲的获取对象列表的方法相同：123vkGetPhysicalDeviceQueueFamilyProperties(info.gpus[0], &amp;info.queue_family_count, NULL);info.queue_props.resize(info.queue_family_count);vkGetPhysicalDeviceQueueFamilyProperties(info.gpus[0], &amp;info.queue_family_count, info.queue_props.data()); info.queue_props 是一个VkQueueFamilyProperties的实例变量，上面的代码与之前的获取对象的模式相同，不在赘述。 VkQueueFamilyProperties 结构体被称为”family”的原因是：在queueFlags的某种标志下，可能有好几个(queueCount)可以使用的队列。例如，VK_QUEUE_GRAPHICS_BIT集合中，有8个可以使用的队列。例图如下： 上图中，VKPhysicalDevice使用vkGetPhysicalDeviceQueueFamilyProperties()函数获得了两个VkQueueFamilyProperties实例，queue_props[0]集合类型是VK_QUEUE_GRAPHICS_BIT，queueCount值为8；queue_props[1]集合类型是VK_QUEUE_TRANSFER_BIT，queueCount值为1。 VKQueueFlagBits规定了硬件队列处理的工作流程顺序。比如，某个物理设备会为一般的3D图形操作定义VK_QUEUE_GRAPHICS_BIT队列，但同时该物理设备也支持 pixel block copies ，那它会再定义一个VK_QUEUE_TRANSFER_BIT队列，这就使图形设备能够进行并行图形操作成为了可能。 某些时候，有一些简单的GPU会只返回一个有多重队列属性标记的队列，如图：此时，你需要对FlagBits进行位运算来找某一种队列：12345678bool found = false;for (unsigned int i = 0; i &lt; info.queue_family_count; i++) &#123; if (info.queue_props[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123; queue_info.queueFamilyIndex = i; found = true; break; &#125;&#125; Creating the Logical Device获取设备队列之后，创建虚拟设备(logical device)的代码如下：1234567891011121314VkDeviceCreateInfo device_info = &#123;&#125;;device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;device_info.pNext = NULL;device_info.queueCreateInfoCount = 1;device_info.pQueueCreateInfos = &amp;queue_info;device_info.enabledExtensionCount = 0;device_info.ppEnabledExtensionNames = NULL;device_info.enabledLayerCount = 0;device_info.ppEnabledLayerNames = NULL;device_info.pEnabledFeatures = NULL;VkDevice device;VkResult res = vkCreateDevice(info.gpus[0], &amp;device_info, NULL, &amp;device);assert(res == VK_SUCCESS); 上面代码提到的enabledExtension所指的扩展，在下面的内容很快会讲到；enabledLayer设置为0，在这里device layers在Vulkan中已被弃用，所以并不需要在创建设备时去指定devbice layers。在执行这段代码之后，我们将获得一个设备的对象，这之后我们可以通过创建命令缓冲区来向设备发送图形指令了。 Command Buffer本章节代码在源文件04-init_command_buffer.cpp中。 Basic Command Buffer Operation在Vulkan中，采取了一种与OpenGL不同的绘图指令API，是通过调用函数vkCmdSetLineWidth()向命令缓冲区(command buffer)中添加一条操作的。因为每个GPU都有属于自己的指令集(instruction set)，驱动程序就会做一些额外的生成特定GPU指令来设置线段宽度的工作：在上图中，驱动程序制定一条合适的二进制GPU指令，用于向命令队列中插入一条操作：使GPU画一条宽度为5的线段。我们没有必要看到buffer中的内容，驱动程序会为我们将buffer的内容转换成GPU程序。 接下来我们需要学习的是如何去获取一个命令缓冲区。这里需要了解Vulkan的Command Buffer Pools类型，从04-init_command_buffer.cpp的代码中可以了解是如何获取一个命令缓冲区的。 Command Buffer Pools 众所周知，创建和销毁单个命令缓冲区的开销是昂贵的，因此Vulkan用命令缓冲池(Command Buffer Pools)来管理命令缓冲区，使用命令缓冲池有下面几点考虑： 有一些程序会使用生命周期短的命令缓冲区，这就意味着这些缓冲区会被频繁地创建和销毁。使用专门的缓冲池来管理并分配这些命令缓冲区会提高程序效率。 命令缓冲区内存的特殊点在于：它必须对CPU和GPU都是可见的。在众多操作系统中，实现一处从内存到处理器的映射需要占用很长的一段时间片(锁，同步，传输等时间占用)，当采用小的缓冲区来装同样多的命令，则会产生许多个映射，会在传输之外的步骤上浪费大量时间。 内存映射是一个代价高昂的操作，它通常涉及内存页表的修改以及对TLB内存缓冲状态的设置。因此，使用内存映射的最好的方法是将一个大块的缓冲池当作映射区，只做一次映射，然后在这块缓冲池中进行小的缓冲区的分配，而不是将每个缓冲区单独映射到处理器。 Command Buffer Pools and Queue Families 驱动软件会采用最适合GPU硬件读取命令队列的内存分配特性。比如：要求内存严格对齐、使用缓存(cache behavior)。如果有多个硬件GPU队列，驱动会按照物理设备队列族(physical device queue families)中对GPU队列的描述，专门为每个GPU硬件队列分配有对应特性的命令缓冲池。这里面的细节会由驱动程序在得到队列组时进行处理完成的。如此，一个命令缓冲池只对应一个队列族，当我们通过API创建缓冲池时，需要制定队列族的index:1234567VkCommandPoolCreateInfo cmd_pool_info = &#123;&#125;;cmd_pool_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;cmd_pool_info.pNext = NULL;cmd_pool_info.queueFamilyIndex = info.graphics_queue_family_index;cmd_pool_info.flags = 0;res = vkCreateCommandPool(info.device, &amp;cmd_pool_info, NULL, &amp;info.cmd_pool); 注意：当你创建逻辑设备时，就应当确定使用哪些硬件队列。实际上，你应当为每一个将要被应用程序使用的单独的队列组创建一个命令缓冲池。由于我们的样例中只为逻辑设备创建了一个队列族，创建一个命令缓冲池足矣。 Creating the Command Buffer创建一个命令缓冲池之后，从缓冲池中取出一个缓冲区就容易多了：12345678VkCommandBufferAllocateInfo cmd = &#123;&#125;;cmd.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;cmd.pNext = NULL;cmd.commandPool = info.cmd_pool;cmd.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;cmd.commandBufferCount = 1;res = vkAllocateCommandBuffers(info.device, &amp;cmd, &amp;info.cmd); 注意：分配缓冲区的API实际上可以一次调用分配更多的命令缓冲区，但本样例是一个简单的演示，因此只分配了一个命令缓冲区。 Using Command Buffers创建命令缓冲区后，我们调用 vkBeginCommandBuffer() 函数来开始向缓冲区中写入命令，调用该函数之后，可以使用 vkCmd* 函数向缓冲区写入命令。比如，在本章节开始时使用到的 vkCmdSetLineWidth() 函数。再比如，vkCmdDraw() 函数告诉GPU开始画出顶点。当我们需要结束命令的写入，我们需要调用 vkEndCommandBuffer() 来表明结束缓冲区写入命令的过程。在随后的章节中，我们看到的代码实际上都是已经在创建缓冲区之后的代码。 调用结束函数并不会让GPU去执行缓冲区中的命令。如果需要GPU去执行缓冲区的命令，我们需要使用 vkQueueSubmit() 函数向GPU的硬件队列提交缓冲区命令。不过在调用提交函数之前，还需要进行一些列设置，这将在下面的章节中进行讲解。 本篇Vulkan Samples Tutorial原文是LUNAEXCHANGE中的Vulkan Tutorial的译文。并非逐字逐句翻译，如有错误之处请告知。O(∩_∩)O谢谢~~","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"Processing Program","slug":"Processing Programs","date":"2017-03-13T14:29:29.000Z","updated":"2017-06-26T01:42:02.315Z","comments":true,"path":"2017/03/13/Processing Programs/","link":"","permalink":"https://domacles.github.io/2017/03/13/Processing Programs/","excerpt":"","text":"Processing 简介Processing是一种具有革命前瞻性的新兴计算机语言，它的概念是在电子艺术的环境下介绍程序语言，并将电子艺术的概念介绍给程序设计师。它是 Java 语言的延伸，并支持许多现有的 Java 语言架构，不过在语法 (syntax) 上简易许多，并具有许多贴心及人性化的设计。Processing 可以在 Windows、MAC OS X、MAC OS 9 、Linux 等操作系统上使用。目前最新版本为Processing 3.3。以 Processing 完成的作品可在个人本机端作用，或以Java Applets 的模式外输至网络上发布。 虽然图形用户界面(GUI)早在二十年前成为主流，但是基础编程语言的教学到今天仍是以命令行接口为主，学习编程语言为什么要那么枯燥呢？人脑天生擅长空间辨识，图形用户界面利用的正是这种优势，加上它能提供各种实时且鲜明的图像式反馈 (feedback)，可以大幅缩短学习曲线，并帮助理解抽象逻辑法则。举例来说，计算机屏幕上的一个像素(pixel) 就是一个变量值(the value of a variable) 的可视化表现。Processing将Java的语法简化并将其运算结果“感官化”，让使用者能很快享有声光兼备的交互式多媒体作品。 Processing的源代码是开放的，和近来广受欢迎的 Linux 操作系统、Mozilla浏览器、或Perl语言等一样，用户可依照自己的需要自由裁剪出最合适的使用模式。Processing的应用非常丰富，而且它们全部遵守开放源代码的规定，这样的设计大幅增加了整个社群的互动性与学习效率。 无意中找到了这个……话说，我在公司里负责三维模型的处理，而我司的垃圾代码不仅经常出Bug，还要什么没什么，基本上只有一个简单的Mesh数据结构(OpenMesh)，矩阵计算也只支持 4 4 规模的。而我处理三维模型的点线面需要用到多维矩阵。不仅如此，接口调用复杂，一个想法难以用这套软件快速实现……最主要是没有API文档，没有注释，也不给看函数的实现，给的全是*lib文件！！！ 我想写一下Delaunay三角化算法的实现也得先从参数化开始一步一步实现…… Processing 真是及时雨啊。 这里有一个3D Delauny Triangulation算法来自：www.openprocessing.org - By Tercel，是一个日本人写的代码，我跑了一下效果如下： 感谢 openprocessing 软件的支持 Tercel 的实现 jakkubu 的另外一种实现","categories":[],"tags":[{"name":"CG","slug":"CG","permalink":"https://domacles.github.io/tags/CG/"}]},{"title":"Vulkan 简介与使用","slug":"Vulkan 简介","date":"2017-03-07T18:18:13.000Z","updated":"2017-06-26T01:42:02.349Z","comments":true,"path":"2017/03/08/Vulkan 简介/","link":"","permalink":"https://domacles.github.io/2017/03/08/Vulkan 简介/","excerpt":"","text":"Vulkan介绍 使用Vulkan之前的准备 Vulkan SDK安装与使用指南 Vulkan SDK的下载 Vulkan SDK的安装 感谢 Vulkan介绍Vulkan 是一个低CPU开销、跨平台的2D和3D绘图与计算的应用程序接口（API），最早由科纳斯组织（Khronos）在2015年游戏开发者大会（GDC）上发表。科纳斯最先把Vulkan API称为“次世代OpenGL行动”（next generation OpenGL initiative）或“glNext”，但在正式宣布Vulkan之后这些名字就没有再使用了。 Vulkan基于Mantle而构建，这是由于 AMD 将 Mantle API 捐赠给科纳斯组织，给予该组织开发底层API的基础，使其成为行业标准。 与OpenGL类似，Vulkan针对全平台即时3D程序（如电子游戏和交互媒体）设计，并提供高性能与更均衡的CPU/GPU使用，这也是Direct3D 12和AMD的Mantle的目标。与Direct3D（12版之前）和OpenGL的其他主要区别是，Vulkan是一个底层API，并且能执行并行任务。除此之外，Vulkan还能更好地分配多个CPU核心的使用。 使用Vulkan之前的准备 PC配备一块支持Vulkan的显卡，并安装支持Vulkan的显卡驱动(NVDIA, AMD, Inter) 具备使用C++的经验(RAII, Class, STL…) 支持C++11的编译器(VS 2013+, GCC 4.8+, Clang…) 有一定的计算机图形学基础，了解一些OpenGL渲染运行机制 注意：实际上Vulkan也提供了C Vulkan API， 如果使用windows系统，安装LUNAR vulkan SDK后，可以按照使用说明建立VS工程：Vulkan Program，Vulkan Windowed Program，Vulkan C++ Program，Vulkan C++ Windowed Program。 Vulkan SDK安装与使用指南LunarG Vulkan SDK 提供了一套用于创建、运行并调试 Vulkan 应用程序的开发和运行组件。但该 SDK 并不提供支持Vulkan的驱动程序，驱动程序需要从你所使用的显卡提供商那进行获取并安装。 在使用 SDK 之前需要了解下面这7个术语： Term Description ICD Installable Client Driver — A Vulkan-compatible display driver（安装在PC上的支持Vulkan的驱动程序） GLSL OpenGL Shading Language（OpenGL的着色器语言，Vulkan支持） Layer A library designed to work as a plug-in for the loader. It usually serves to provide validation and debugging functionality to applications（一种可用于加载器的插件库，这个库可以为应用程序的图形渲染提供检查和调试功能，插件） Loader A library which implements the Vulkan API entry points and manages layers, extensions, and drivers. It can be found in the SDK, as well as independent hardware vendor driver installs（独立于硬件驱动安装的软件库，是用于实现Vulkan API入口，管理插件、扩展和驱动程序。） SPIR-V Standard Portable Intermediate Representation — A cross-API intermediate language that natively represents parallel compute and graphics programs（SPIR-V 中间语言(比如GLSL)，用于程序与硬件进行交流的语言） Vulkan A low overhead, explicit graphics API developed by the Khronos Group and member companies（一个由科纳斯组织及其成员设计的底层图形API） WSI Window System Integration（窗口系统集组件） Vulkan SDK的下载点击Vulkan.LunarG.com的“Download Vulkan Tools for Windows”下载其中的VulkanSDK version Installer.exe程序，打开安装即可。如果你使用的是Linux系统则需要到该网站的Linux下载安装页面进行安装。 Vulkan SDK的安装Windows系统安装完成之后需要为Vulkan SDK配置环境变量。 在变量中添加VULKAN_SDK变量，变量的值为安装的Vulkan SDK的位置，SDK的默认安装位置在C:\\VulkanSDK\\version下，version是版本号。 在变量中添加VK_SDK_PATH变量，变量的值与VULKAN_SDK相同。 在环境变量（PATH）中添加：$VULKAN_SDK\\Bin（32位操作系统则添加$VULKAN_SDK\\Bin32）。 Vulkan loader程序，即vulkan-1.dll，在32位的系统上需要将32位版本的dll安装到C:\\Windows\\System32中，64位的系统上需要将64位版本的dll安装到C:\\Windows\\SysWOW64中。 注意：实际上上面的步骤只是需要检查一下，如果Vulkan SDK的安装软件并没有设置这些环境变量则需要手动加上。 感谢 Getting Started with the Vulkan SDK - LunarG","categories":[],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://domacles.github.io/tags/Vulkan/"}]},{"title":"C++ 11 模版的使用","slug":"C++ 11 模版使用","date":"2017-03-05T02:37:28.000Z","updated":"2017-06-26T01:42:02.314Z","comments":true,"path":"2017/03/05/C++ 11 模版使用/","link":"","permalink":"https://domacles.github.io/2017/03/05/C++ 11 模版使用/","excerpt":"","text":"为什么要使用模版 关键字 typename C++ 11新的模版特性 - 变参模板 C++ 11新的模板特性 - 外部模板 C++ 11新的模版特性 - 模版别名 C++ 11新的模板特性 - 默认模板实参 C++ 11新的模板特性 - 回返类型后置的函数声明 C++ 11新的模板特性 - 用于元编程的类别属性 感谢 为什么要使用模版在声明变量、函数和大多数其他类型的实体的时候，C++要求我们使用特定的类型。然而许多代码除了类型不同不同之外，其余代码都看起来是相同的。比如sort()函数，每当你实现了一个顺序容器，就需要重新写一个sort()函数…… 如果程序设计语言并不支持这个语言特性，为了实现相同的功能，你只能使用下面这些糟糕的替代方法： 针对每个所需相同行为的不同类型，你可以一次又一次地实现它。 你可以把通用代码放在一个注入Object或者void*的公共基础类里面。 你可以使用特殊的预处理程序，如#define。 而在Java和C等类似的语言中，上面的方法都有自身的缺点： 做了许多重复工作，会趋向舍弃复杂但更好用的算法来保证尽可能不出错，复杂算法通常都趋向于引入更多的错误。 采用公共基类编写代码，会失去类型检查这个优点。另外，对于以后实现的许多类都必须继承自某个特定的基类，这会令代码的维护更加困难。 如如果使用了预处理程序，你会使代码变得格式混乱难以阅读，使用“文本替换机制”并不会考虑作用域和类型。 在现今的程序中，模版的应用非常广泛。C++的标准库中，几乎所有代码都是模版代码。 关键字 typename关键字typename用来指明紧跟其后的名称是个类型的名称。最常用在template之后，比如：12345template &lt;typename T&gt;class MyClass&#123;private: T val;&#125;; 我们应该尽可能使用typename取代class在template后面的尖括号中的应用。当然，关键字typename不仅仅只有这一个用法，还可以像下面的方式进行使用：1234template&lt;typename T&gt;class MyClass&#123; typename T::SubType *ptr;&#125;; 在这里typename用来阐明“SubType是个类型，定义于class T内”。因此，ptr是个指针，指向类型为T::SubType。 如果没有typename，则SubType会被视为一个static成员，于是T::SubType *ptr被视为“类型T的数值SubType”乘以ptr。“基于SubType必须是个类型”这样的限定，任何被用来替换T的类型，都必须提供一个内层类型SubType。比如下面的Test类:12345class Test &#123;public: void print() &#123;&#125; using SubType = int;&#125;; 在这里，using SubType = int;等价于typedef int SubType;。C++ 11的关键字using的新的用法比原来的typedef更加强大，建议使用。 C++ 11新的模版特性 - 变参模板自C++11起，template可拥有那种“得以接受不确定个数的template实参”的个数。此能力被称为 variadic template。下面代码是print()使用变参模版的实现方式：1234567void print() &#123;&#125;template &lt;typename T, typename... Types&gt;void print(const T&amp; firstArg, const Type&amp;... args)&#123; std::cout &lt;&lt; firstArg &lt;&lt; std::endl; // 输出第一个参数 print(args...); // 输出剩余的参数，如果没有剩余，则调用print()&#125; 这是一种递归写法，必须提供一个不用template的重载函数print()，才能结束整个递归过程。如同下面的使用一个用了template的print()的方法虽然可能通过编译，但不推荐：1234567891011template &lt;typename T&gt;void print(const T&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; std::endl;&#125;template &lt;typename T, typename... Types&gt;void print(const T&amp; firstArg, const Type&amp;... args)&#123; std::cout &lt;&lt; firstArg &lt;&lt; std::endl; // 输出第一个参数 print(args...); // 输出剩余的参数&#125; 并不确定在只有一个参数的时候，该调用哪一个print()。这种会形成歧义的代码应当避免。 在实验楼的《C++ 11/14 高速上手教程中-语言可用性的强化》(需要账号登录)提供了一种使用std::initializer_list和lambda表达式的写法(修改版)：12345678910template&lt;typename... Args&gt;void print(Args&amp;&amp;... args)&#123; cout &lt;&lt; sizeof...(args) &lt;&lt; endl; auto res = std::initializer_list&lt;int&gt;&#123; ([](const Args&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; std::endl; return 0; &#125;)(args)...&#125;;&#125; 这个写法利用了std::initializer_list对args的展开...所用到的初始化列表构造函数，由于std::initializer_list&lt;int&gt;在这里接受的是int类型的初始化列表，所以匿名lambda表达式返回整数0用于填充std::initializer_list。但在上面的教程说道，可以使用std::bind和完美转发进行args的...操作并转发。没想到该如何做。另外，该做法虽然简洁，但性能问题并不确定，如需使用请通过大规模的调用进行与递归式的测试进行比较，选用最合适的方法。 C++ 11新的模板特性 - 外部模板在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化（instantiate）。这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。看起来没有办法告诉C++不要引发模板的实例化。C++11将会引入外部模板这一概念。C++已经有了强制编译器在特定位置开始实例化的语法：1template class std::vector&lt;MyClass&gt;; 而C++所缺乏的是阻止编译器在某个编译单元内实例化模板的能力。C++11将简单地扩充前文语法如下：1extern template class std::vector&lt;MyClass&gt;; 这样就告诉编译器不要在该编译单元内将该模板实例化。使用方法如下：12345678910111213141516//fun.h template &lt;typename T&gt; void fun(T t)&#123; &#125; //use1.cpp void test1()&#123; fun&lt;int&gt;(1); &#125; //use2.cpp extern template void fun&lt;int&gt;(int); void test2()&#123; fun&lt;int&gt;(1); &#125; extern有两个作用： 第一个,当它与&quot;C&quot;一起连用时，如: extern &quot;C&quot; void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释! 第二，当extern不与&quot;C&quot;在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。 C++ 11新的模版特性 - 模版别名自C++11起，支持使用关键字using来命名一个模板的Alias Template，示例如下：1234567命名方法:template&lt;typename T&gt;using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;;使用方法:Vec&lt;int&gt; coll; 等价于:std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll; 上面这样的使用方法，可以避免像STL的vector源码中的各种#define，能很大程度提高模板的可读性。 C++ 11新的模板特性 - 默认模板实参这里应该提一下以前的一个关于模板的特性，非类型模板参数(Nontype Tempalte Parameter), 声明方法如下：1234567template&lt; typename T, typename U, int value&gt;class SuckType &#123;public: T a; U b; SuckType():a(value),b(value)&#123;&#125;&#125;; 这样在使用SuckType的时候，就可以使用int值使用SuckType类模板生成一个类型：1SuckType&lt;int, long, 1024&gt; suckType; 这种用法，在线性代数库 Eigen 中的矩阵模板大规模进行使用。 C++ 11新的模板特性 - 回返类型后置的函数声明C++11引进一种新的函数定义与声明的语法：12345template&lt; typename LHS, typename RHS&gt; auto AddingFunc(const LHS &amp;lhs, const RHS &amp;rhs) -&gt; decltype(lhs+rhs) &#123; return lhs + rhs;&#125; 用于解决模板类型推导的实现。这种语法也能套用到一般的函数定义与声明：123456789struct SomeStruct&#123; auto FuncName(int x, int y) -&gt; int;&#125;;auto SomeStruct::FuncName(int x, int y) -&gt; int&#123; return x + y;&#125; C++ 11新的模板特性 - 用于元编程的类别属性模版元编程（template metaprogram）是C++中最复杂也是威力最强大的编程范式，它是一种可以创建和操纵程序的程序。模版元编程完全不同于普通的运行期程序，它很独特，因为模版元程序的执行完全是在编译期，并且模版元程序操纵的数据不能是运行时变量，只能是编译期常量，不可修改，另外它用到的语法元素也是相当有限，不能使用运行期的一些语法，比如if-else，for等语句都不能用。因此，模版元编程需要很多技巧，常常需要类型重定义、枚举常量、继承、模板偏特化等方法来配合，因此编写模版元编程比较复杂也比较困难。 模版元程序由元数据和元函数组成，元数据就是元编程可以操作的数据，即C++编译器在编译期可以操作的数据。元数据不是运行期变量，只能是编译期常量，不能修改，常见的元数据有enum枚举常量、静态常量、基本类型和自定义类型等。 元函数是模板元编程中用于操作处理元数据的“构件”，可以在编译期被“调用”，因为它的功能和形式和运行时的函数类似，而被称为元函数，它是元编程中最重要的构件。元函数实际上表现为C++的一个类、模板类或模板函数：12345template&lt;int N, int M&gt;struct meta_func&#123; static const int value = N+M;&#125; 调用元函数获取value值：cout&lt;&lt;meta_func&lt;1, 2&gt;::value&lt;&lt;endl;模板元编程产生的源程序是在编译期执行的程序，因此它首先要遵循C++和模板的语法，但是它操作的对象不是运行时普通的变量，因此不能使用运行时的C++关键字（如if、else、for），可用的语法元素相当有限，最常用的是： enum、static、const，用来定义编译期的整数常量； typedef/using，用于定义元数据； T、Args...，声明元数据类型； template，主要用于定义元函数； ::，域运算符，用于解析类型作用域获取计算结果（元数据）。 模板元编程中的if-else等逻辑通过type_traits来实现，它不仅仅可以在编译期做判断，还可以做计算、查询、转换和选择。type_traits是C++11提供的模板元基础库，通过type_traits可以实现在编译期计算、查询、判断、转换和选择，提供了模板元编程需要的一些常用元函数。 模板元中的for等逻辑可以通过递归、重载、和模板特化(偏特化)等方法实现。 这个元编程需要仔细再看看。 感谢 C++ 11/14 高速上手教程 - 语言可用性的强化 - 实验楼 C++11 - 中文维基百科","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://domacles.github.io/tags/C/"}]},{"title":"C++ 11 右值引用","slug":"C++ 11 右值引用","date":"2017-03-03T12:34:09.000Z","updated":"2017-06-26T01:42:02.314Z","comments":true,"path":"2017/03/03/C++ 11 右值引用/","link":"","permalink":"https://domacles.github.io/2017/03/03/C++ 11 右值引用/","excerpt":"","text":"右值引用解决的问题 C++11之前与Java的对比 C++11右值引用 std::move(val) 和 std::forward(T&amp;&amp; val) 的作用 右值引用使用注意 何时发生移动，何时发生复制 感谢 右值引用解决的问题右值引用是 C++11 中最重要的新特性之一，它解决了C++中大量的历史遗留问题，使C++标准库的实现在多种场景下消除了不必要的额外开销(如std::vector, std::string)，也使得另外一些标准库成为可以实现的可能。在 C++11 之前，移动语义的确实是C++饱受诟病的问题之一。 使用右值引用特性，可以实现：移动语义(move) 和 完美转发(perfect forwarding)。 C++11之前与Java的对比右值引用与对象的资源所有权的交换复制有关。 在之前初学Java时，我们就要明确两个概念：深复制 和 浅复制 。 深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。 浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 在Java当中，所有的参数与赋值符号，实现的所有权转移都是使用传递引用，这里的引用与C中的引用概念类似，但C中的引用在使用过程中并不能改变引用的对象。Java 示例代码：1234567891011public static void main(String args[]) &#123; long t1 = System.currentTimeMillis(); Professor p = new Professor(&quot;wangwu&quot;, 50); Student s1 = new Student(&quot;zhangsan&quot;, 18, p); Student s2 = s1; // 浅复制 s2.p.name = &quot;lisi&quot;; s2.p.age = 30; System.out.println(&quot;name=&quot; + s1.p.name + &quot;,&quot; + &quot;age=&quot; + s1.p.age); long t2 = System.currentTimeMillis(); System.out.println(t2-t1); &#125; 在上述代码中，s2改变则s1也会随之改变，很多情况下，当把s1放到一个函数参数位置上当作参数，参数获取的仍然也是s1的引用。但有一些函数提供复制的语义，如字符串的 “+” 操作符，它会将两个字符串拼成一个，但却是在内存中重新分配了空间。 浅复制 是移动语义的实现方法，速度快，同时能够保证不同作用域可以操作同一个对象。而当我们需要使用复制语义存储某一对象的副本时，例如我们存储一个Student对象的副本到ArrayList中，当我们改变了Student，ArrayList中的也随之改变，这并不是我们想要的结果，因此，需要使用 深复制。 123456789101112131415class Student implements Serializable &#123; Student(String name, int age, Professor p) &#123; this.name = name; this.age = age; this.p = p; &#125; public Object deepClone() &#123; ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (oi.readObject()); &#125;&#125; 上述代码使用输入输出流将对象 串行化 之后进行了复制，返回了复制的对象的引用，调用这个函数可以获得一个Studnet的实例的副本。 在C++中，浅复制代码可以写成下面这样：12345678910int main() &#123; Professor p = Professor(&quot;wangwu&quot;, 50); Student s1 = new Student(&quot;zhangsan&quot;, 18, p); Student s2 = s1; // 深复制 s2.p.name = &quot;lisi&quot;; s2.p.age = 30; cout&lt;&lt; &quot;name=&quot; + s1.p.name + &quot;,&quot; + &quot;age=&quot; + s1.p.age &lt;&lt; endl; return 0; &#125; 而在C++的表现却是s1与s2并不是指向同一个对象，s1的改变并不会影响到s2中的值。 赋值符号”=”在这里会调用s2的复制构造函数，将s1当做复制构造函数的参数进行调用。如果不使用指针，无法实现Java中的浅复制。 C++之所以与Java在内存管理方面存在上面所述的差异，原因是他们两种语言的内存回收方式的不同。C++（RAII机制）在栈上创建的对象(如局部变量)在离开作用于就会被析构，在堆上分配内存的对象只有在调用 delete 之后或者程序结束之后才会释放，而Java采用垃圾回收算法来判断是否回收创建的对象。 C++的指针设计简单，应用灵活，但却很容易造成内存泄漏(即便采用 谁开发谁治理 谁负责申请内存谁就负责销毁的方法，在一些过程函数中难以定义“谁”，且在多人协作容易出现问题)，Java虽然采用垃圾回收机制却仍然无法避免使用不当产生的内存泄漏。 C++11右值引用右值引用是C++11引入的与Lambda表达式齐名的重要特征之一。 右值引用了解之前需要明确这几个定义：左值、右值，C++11标准中将右值划分出的纯右值、将亡值。 左值(lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。函数名和变量名（实际上是函数指针③和具名变量，具名变量如std::cin、std::endl等）、返回左值引用的函数调用、前置自增/自减运算符连接的表达式++i/–i、由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）、解引用表达式*p、字符串字面值”abc”等。 右值(rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。 纯右值(prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true；要么是求值结果相当于字面量或匿名(不具名)临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。 将亡值(xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够(或者说要使用移动)被移动的值。 将亡值可能稍有些难以理解，我们来看这样的代码：12345std::vector&lt;int&gt; createAVector() &#123; std::vector&lt;int&gt; res = &#123;1, 2, 3, 4&#125;; return res;&#125;std::vector&lt;int&gt; v = createAVector(); 在这样的代码中，函数 createAVector 的返回值 res 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 res 拷贝一份，然后把 res 销毁，如果这个 res 非常大，这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，v 是左值、createAVector() 返回的值就是右值（也是纯右值）。 但是，v 可以被别的变量捕获到，而 createAVector() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。 将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。 需要拿到一个将亡值，就需要用到右值引用的申明：T &amp;&amp;，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：1234567891011121314151617181920212223242526void reference(std::string&amp; str) &#123; std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;&#125;void reference(std::string&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;&#125;int main()&#123; std::string lv1 = &quot;string,&quot;; // lv1 是一个左值 // std::string&amp;&amp; r1 = s1; // 非法, 右值引用不能引用左值 std::string&amp;&amp; rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout &lt;&lt; rv1 &lt;&lt; std::endl; // string, const std::string&amp; lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的申明周期 // lv2 += &quot;Test&quot;; // 非法, 引用的右值无法被修改 std::cout &lt;&lt; lv2 &lt;&lt; std::endl; // string,string std::string&amp;&amp; rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象声明周期 rv2 += &quot;Test&quot;; // 合法, 非常量引用能够修改临时变量 std::cout &lt;&lt; rv2 &lt;&lt; std::endl; // string,string,string, reference(rv2); // 输出左值 return 0;&#125; 注意：rv2 虽然引用了一个右值，但由于它是个具名变量可以在后面的代码中使用，所以 rv2 是一个左值。 在程序设计中，我们重点的是如何使用右值引用才能使程序效率提高，而不是区分哪些是左值，哪些是右值。 事实上，将亡值不过是C++11提出的一块晦涩的语法糖。它与纯右值在功能上及其相似，如都不能做操作符的左操作数，都可以使用移动构造函数和移动赋值运算符。当一个纯右值来完成移动构造或移动赋值任务时，其实它也具有“将亡”的特点。一般我们不必刻意区分一个右值到底是纯右值还是将亡值。 std::move(val) 和 std::forward(T&amp;&amp; val) 的作用std::move(val) 会将val强制转换成右值并返回该右值，代码如下（MSVC）：123456template&lt;class _Ty&gt; inline constexpr typename remove_reference&lt;_Ty&gt;::type&amp;&amp; move(_Ty&amp;&amp; _Arg) _NOEXCEPT &#123; // forward _Arg as movable return (static_cast&lt;typename remove_reference&lt;_Ty&gt;::type&amp;&amp;&gt;(_Arg)); &#125; std::forward&lt;T&gt;(T&amp;&amp; val) 会将val转换成与其传入时相同的类型并将转换后的进行返回，即如果传入时是左值则返回左值，如果传入的是右值则返回右值，实现代码（MSVC）如下： 123456template&lt;class _Ty&gt; inline constexpr _Ty&amp;&amp; forward(typename remove_reference&lt;_Ty&gt;::type&amp;&amp; _Arg) _NOEXCEPT &#123; // forward an rvalue as an rvalue static_assert(!is_lvalue_reference&lt;_Ty&gt;::value, &quot;bad forward call&quot;); return (static_cast&lt;_Ty&amp;&amp;&gt;(_Arg)); &#125; 使用方法如下：1234567891011121314151617181920212223void fun(int &amp;x) &#123; cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; endl; &#125; void fun(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; endl; &#125; void fun(const int &amp;x) &#123; cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; endl; &#125; void fun(const int &amp;&amp;x) &#123; cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; endl; &#125; template&lt;typename T&gt; void PerfectForward(T &amp;&amp;t) &#123; fun(std::forward&lt;T&gt;(t)); &#125; int _tmain(int argc, _TCHAR* argv[]) &#123; PerfectForward(10); // rvalue ref int a; PerfectForward(a); // lvalue ref PerfectForward(std::move(a)); // rvalue ref const int b = 8; PerfectForward(b); // const lvalue ref PerfectForward(std::move(b)); // const rvalue ref system(&quot;pause&quot;); return 0; &#125; 完美转发涉及到了引用折叠规则(reference collapsing rule), 以及一个特殊原则，在 2.两个原则 中有讲到，这两个原则应当归属在 模板 的新增特性里。 注意：为了避免这两个原则对我们造成思维混乱，将其归为 完美转发 ，并使用完美转发来解决根据输入的左值或右值调用参数为左值或右值的重载函数。 若要使用上述原则，则需要进行针对性的测试，并能根据实际情况测试出能得到自己想要的结果的使用方法才可以使用。 右值引用使用注意 对于将亡值，如果对象能够调用 移动构造函数 和 移动赋值函数，则会自动使用 移动语义， 因此，对于右值引用在函数返回值方面，最佳使用方法是： 1234567std::vector&lt;int&gt; return_vector(void)&#123; std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;; return tmp;&#125;std::vector&lt;int&gt; rval_ref = return_vector(); 与我们之前写的函数并无其他特殊之处。 无论是左值引用 &amp; 还是右值引用 &amp;&amp;，本质上都是 引用类型（是一种基本类型），以前使用 &amp; 会导致的错误的地方，把 &amp; 替换成 &amp;&amp; 也会出现错误。 错误使用 &amp;&amp; 和 &amp;的方法如下，该方法返回的对象临时的，在返回完成之后会被析构，导致引用指向错误，运行错误： 1234567std::vector&lt;int&gt;&amp;&amp; return_vector(void)&#123; std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;; return std::move(tmp);&#125;std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector(); 1234567std::vector&lt;int&gt;&amp; return_vector(void)&#123; std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;; return tmp;&#125;std::vector&lt;int&gt; &amp;rval_ref = return_vector(); 如何使用右值引用，与上面同理，右值引用也是一种 引用类型，以前为了传参数避免参数调用复制构造而使用 &amp; 传引用的地方，或者返回一个非函数内创建的变量的引用而是用 &amp; 的地方，都是可以使用右值引用 &amp;&amp; 的地方。 &amp;&amp; 与 &amp; 的声明方法相同，只能在声明右值引用的同时必须指定一个引用对象。示例如下： 123456MyString&amp; reference(MyString&amp; v) &#123; // &amp; 引用在参数、返回值上的应用 std::cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; std::endl; return v;&#125;MyString c;MyString&amp; d = reference(c); 123456int&amp;&amp; reference(MyString&amp;&amp; v) &#123; // &amp;&amp; 引用在参数、返回值上的应用 std::cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; std::endl; return std::move(v); // 注意：这里需要将左值v转换成右值&#125;MyString c;MyString&amp;&amp; d = reference(std::move(c)); // 注意：这里需要将左值c转换成右值 上述函数返回引用类型的用法很少用到，如需用到需要参考 输入输出流 的&gt;&gt; 或 &lt;&lt; 运算符的写法。我们经常用到的是在函数参数上声明引用类型，如 reference(MyString&amp; v), 如果我们要使用 移动语义 对某一对象要将其移动函数内进行操作，则可有如下写法： 123456int&amp;&amp; reference(MyString&amp;&amp; v) &#123; // &amp;&amp; 引用在参数、返回值上的应用 MyString&amp;&amp; tmp = std::move(v); ... // op for tmp ... return std::move(tmp); // 注意：这里需要将左值v转换成右值&#125; 而实际上，我认为在使用移动语义的时候配合 完美转发(Perfect Forwarding) 则能够使函数提供更多的用法，典型用法可参考 vector 的 void push_back(value_type&amp;&amp; _Val)。可我怎么觉得我很少能用到 何时发生移动，何时发生复制在实际程序设计时，我们需要知道何时是调用 复制构造函数 与 复制赋值函数，何时调用 移动构造函数 与 移动赋值函数。下面是一个我抄的(出处在最后的链接上)一个类的写法，上面粗体的四个函数都有实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class MyString &#123;private: char* _data; size_t _len; void _init_data(const char *s) &#123; _data = new char[_len + 1]; memcpy(_data, s, _len); _data[_len] = &apos;\\0&apos;; &#125;public: MyString() &#123; _data = NULL; _len = 0; &#125; MyString(const char* p) &#123; _len = strlen(p); _init_data(p); &#125; // 复制构造函数, 标号1函数 MyString(const MyString&amp; str) &#123; _len = str._len; _init_data(str._data); std::cout &lt;&lt; &quot;Copy Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; &#125; // 复制赋值函数, 标号2函数 MyString&amp; operator=(const MyString&amp; str) &#123; if (this != &amp;str) &#123; _len = str._len; _init_data(str._data); &#125; std::cout &lt;&lt; &quot;Copy Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; return *this; &#125; // 移动构造函数, 标号3函数 MyString(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;Move Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125; // 移动赋值函数, 标号4函数 MyString&amp; operator=(MyString&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;Move Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; if (this != &amp;str) &#123; _len = str._len; _data = str._data; str._len = 0; str._data = NULL; &#125; return *this; &#125; virtual ~MyString() &#123; if (_data) free(_data); &#125;&#125;; 接下来我们我们进行试验，来了解 移动 和 复制 的调用情况，先给出试验用的测试：12345678910111213141516int main() &#123; std::vector&lt;MyString&gt; v; MyString a0(&quot;a0&quot;), a1(&quot;a1&quot;), a2(&quot;a2&quot;); a0 = a1; // 测试调用 复制 a0 = std::move(a2); // 测试调用 移动 a0 = MyString(&quot;a4&quot;); // 测试调用 移动 or 复制 a0 = creatAnNumString(1000); // 测试调用 移动 or 复制 v.push_back(MyString(&quot;a5&quot;)); // 测试调用 移动 or 复制 v.push_back(a0); // 测试调用 复制 v.push_back(std::move(a0)); // 测试调用 移动 system(&quot;pause&quot;); return 0;&#125; 在1, 2, 3, 4都定义的情况下，我们会得到下面的结果： 12345678910Copy Assignment is called! source: a1Move Assignment is called! source: a2Move Assignment is called! source: a4Move Assignment is called! source: 1000Move Constructor is called! source: a5Move Constructor is called! source: a5Copy Constructor is called! source: 1000Move Constructor is called! source: a5Move Constructor is called! source: 1000Move Constructor is called! source: 1000 在1,2,3都定义的情况下，我们会得到下面的结果： 12345678910Copy Assignment is called! source: a1Copy Assignment is called! source: a2Copy Assignment is called! source: a4Copy Assignment is called! source: 1000Move Constructor is called! source: a5Move Constructor is called! source: a5Copy Constructor is called! source: 1000Move Constructor is called! source: a5Move Constructor is called! source: 1000Move Constructor is called! source: 1000 在1,2都定义的情况，我们会得到下面的结果： 12345678910Copy Assignment is called! source: a1Copy Assignment is called! source: a2Copy Assignment is called! source: a4Copy Assignment is called! source: 1000Copy Constructor is called! source: a5Copy Constructor is called! source: a5Copy Constructor is called! source: 1000Copy Constructor is called! source: a5Copy Constructor is called! source: 1000Copy Constructor is called! source: 1000 在只定义1的情况下，我们得到了一个运行错误的结果.在Debug的过程中，a0 = MyString(&quot;a4&quot;); 在运行时并未调用标号1函数，那没有调用 复制构造函数 则调用是使用了移动的 移动赋值函数 。 在我们定义了1,3,4的情况下，我们得到如下结果: 12345678910Copy Assignment is called! source: a1Move Assignment is called! source: a2Move Assignment is called! source: a4Move Assignment is called! source: 1000Copy Constructor is called! source: a5Copy Constructor is called! source: a5Copy Constructor is called! source: 1000Copy Constructor is called! source: a5Copy Constructor is called! source: 1000Copy Constructor is called! source: 1000 本次的输出，告诉我们第三句调用的是 移动赋值函数。 在1,2,3,4都未定义的情况下，我们在析构函数的时候，得到了一个运行错误，而析构函数做的是 delete 操作。 上述输出结果告诉我们，要想像 main() 函数中那样调用，并且想得到自己最理想的调用结果，就需要自己设计能用的复制构造函数 与 复制赋值函数，以及 移动构造函数 与 移动赋值函数 或者 遵照C++新标准的推荐，避免使用C风格的指针 。 上述代码可能是使用了C风格的指针，导致在移动赋值函数调用之后，出现问题，本句存疑，容我之后好好想想。 在这里解释一下为什么7行代码却输出了10行输出，原因在于 vector 身上，众所周知，vector 是一个动态数组，其内部的数据是连续存放的，因此，当 vector 每增加一个元素就需要判断一下vector的大小是否已经达到目前分配的最大数量，如果达到了最大数量则需要先申请一个更大的数组，然后将现在的元素 移动 或者 复制 到新的数组中进行存储，然后将新的元素追加到当前数组的最后位置。 注意：一个类型如果明确它是可以移动的，则一定要显式定义它的 移动构造函数 与 移动赋值函数，若是明确它是可以拷贝的，则一定要显式定义它的 复制构造函数 与 复制赋值函数, 如果明确它不可以移动或者拷贝，则将其 私有化 即可封闭相应的函数调用。 注意：涉及到新特性，需要进行针对特性的测试。 感谢 C++11 标准新特性: 右值引用与转移语义 - ibm c++11 中的 move 与 forward - twoon 左值右值的一点总结 - twoon C++11：完美转发的使用 - 一如当初 话说C++中的左值、纯右值、将亡值 - 同勉共进 C++ 11/14 高速上手教程 - 语言运行期的强化 - 实验楼 C++11 rvalues and move semantics confusion (return statement) - stackoverflow Value categories - cppreference.com std::forward 本文抄袭了他们的一些原文，如果作者禁止使用，则请告知，我会第一时间修改。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://domacles.github.io/tags/C/"}]},{"title":"关于字符编码的理解","slug":"关于字符编码的理解","date":"2017-03-02T13:40:31.000Z","updated":"2017-06-26T01:42:02.349Z","comments":true,"path":"2017/03/02/关于字符编码的理解/","link":"","permalink":"https://domacles.github.io/2017/03/02/关于字符编码的理解/","excerpt":"","text":"为什么要写这个东西 字符，字符集，字符编码的联系 一般处理字符的工作流程 我碰到的问题 记录：一些编码应注意的事项 为什么要写这个东西今天要写的一个小程序用来合并几十个文本文件，然后呢我本以为用C++半小时就可以搞完了，但没想到合并VS工程的xml格式的配置文件总是出现一些方块乱码(长得就像扑克牌的方块一样)。百撕不得骑姐，于是我准备晚上回来仔细查一查然后写个总结。当然，充实自己的博客也是个主要目的。 字符，字符集，字符编码的联系这三者的定义： 字符（Character）是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等, 是类字形单位或符号的基本信息。 字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。 字符编码（英语：Character encoding）也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。 在计算机技术发展的早期，如ASCII（1963年）和EBCDIC（1964年）这样的字符集逐渐成为标准。但这些字符集的局限很快就变得明显，于是人们开发了许多方法来扩展它们。对于支持包括东亚CJK字符家族在内的写作系统的要求能支持更大量的字符，并且需要一种系统而不是临时的方法实现这些字符的编码。 于是出现了 ANSI，GB2312，GBK，Big5， Unicode（与UCS字符集关系密切），UTF-8，UTF-16，UTF-32，Base64等等。 更加详细且清楚的解释请移步Jim Liu的《编码歪传——基础篇》。 一般处理字符的工作流程推荐使用UTF-8来进行字符存储，但由于很多系统或者软件会产生一些使用其他字符编码的文件，比如我经常用的VS 2013的代码文件中的中文注释在UTF-8下都是乱码，这时候需要转换到GBK进行读取才可以正常显示。 因此，我们进行字符处理的流程需要先判断一下文件使用什么编码，然后将其转换成Unicode，再将其转换成需要的编码（比如把字符显示的数字转换成二进制的数字排在一起）进行存储。 如何判断一个文件的编码格式：首先判断是否是带BOM的UTF-8格式，如果是，则前三个字节为 EF BB BF 。关于BOM： BOM（Byte-Order Mark，字节序标记）是Unicode码点U+FEFF。它被定义来放在一个UTF-16文件的开头，如果字节序列是FEFF那么这个文件就是大端序，如果字节序列是FFFE那么这个文件就是小端序。UTF-8本身是没有字节序的问题的（因为它是以单个字节为最小单位），但是Windows里面很多编辑器（比如记事本）会多此一举的在UTF-8文件开头加入EF BB FF也就是U+FEFF的UTF-8编码。 如果不是带BOM的UTF-8格式，则需要判断所有的字节是否符合UTF-8的字节规定： 1字节：0xxxxxxx 2字节：110xxxxx 10xxxxxx 3字节：1110xxxx 10xxxxxx 10xxxxxx 4字节：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 如果出现非法字节则不是UTF-8，那读取则依系统情况而定了。同样的，判断其他字符编码也是可以通过寻找非法字符来判断。但即便是没找到非法字符也不一定说明该文件一定是该字符编码。 对于网络传输来说，最好不同端都约定好默认编码格式。UTF-8兼容ASCII编码，而ASCII是传输英文效率最高的一种，所以一般约定为ASCII编码。 我碰到的问题带BOM格式的UTF-8的读取：无论用C++字符流还是字节流读取文件后，总是有些字符是乱码，原因已经找到，感谢Jim Liu的文章《编码歪传——番外篇》为我解惑。我读取的有些文件是带BOM标记的，而我讲这些文件的所有字符都存到同一个文件中，就会发现这些BOM是乱码，明天就把这几个字符删掉去。 我们采用xml配置的软件dll调用接口，一旦用文本文档打开后，再关闭就发现解析错误，之前发现文本文档会添加三个字符，于是删掉时候就可以正常解析了。这个问题原因就是我们的解析代码并没有针对BOM进行处理。也就这样吧，我又没权限修改代码，技术总监是傻逼And顽固不化And异想天开And瞎指挥又没将所有代码开放给我们这些开发人员。sad… 记录：一些编码应注意的事项待补吧……","categories":[],"tags":[{"name":"Character encoding","slug":"Character-encoding","permalink":"https://domacles.github.io/tags/Character-encoding/"}]},{"title":"搭建github.io静态博客遇到的问题","slug":"搭建github-io静态博客遇到的问题","date":"2017-03-01T13:39:00.000Z","updated":"2017-06-26T01:42:02.349Z","comments":true,"path":"2017/03/01/搭建github-io静态博客遇到的问题/","link":"","permalink":"https://domacles.github.io/2017/03/01/搭建github-io静态博客遇到的问题/","excerpt":"","text":"为什么我需要一个博客 搭建Github.io博客的原理 搭建Gihub.io博客的工具 写博文完善自己的博客 我碰到的问题 我的一些想法 为什么我需要一个博客很早之前ACM训练时在CSDN上开过一个博客，经常将自己的题解贴到上面去，可惜这个习惯并没有坚持太久(是懒病犯了……)。现在毕业差不多半年了，感觉需要将最近看到的东西以及以后看到的东西总结总结，写写读书笔记，最近看C++感觉记忆力不够用了。 想去买个VPS，接触过Node.js之后，又想过自己试着写一个，虽然自我感觉很不错(年轻人经常自大……)，但由于本人是写C++的，虽然学会了TypeScript但从来没怎么用过，随着时间(当然是逐渐忘了……)流逝，各种框架一个版本一个版本地更新，真没时间去练习…… 但后来，我觉得不能这么悠闲得生活下去，得提高自己的知识水平才行，说不定出现什么不幸的事件，那只得靠自己了。 今天刷知乎时，看到教你免费搭建个人博客，Hexo&amp;Github —— 崔斯特的博客，感觉可行啊，那就自己搭一个~~ 搭建Github.io博客的原理简单了解了一下，Github的域名分为两个: github.com 和 github.io，不同的域名可以采用不同安全策略，保证托管在Github上的代码不会因为Cookie被利用而遭到破坏；数据做了划分处理，可以放到不同的服务器上进行保存，比较容易进行分流等等。 github.io可以将代码仓库中的静态网页渲染到浏览器上，因此，创建一个xxx.github.io仓库然后在里面存贮博客的静态网页，如此我们就可以使用 https://yourname.github.io/ 就可以访问自己的博客，浏览文章内容了。 搭建Gihub.io博客的工具这世界上有很多生成静态网页的程序可以用来搭建博客，我用的是 Hexo ， 官方网站在这里。这是一个使用Node.js写出来的工具，有这么几个优点： 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。(我相信也一定支持TypeScript) 这之后，为了让自己的博客变得更好看一些，我使用了主题 NexT , 官方网站在这里。这个主题应该是使用人数最多的主题，在github上的star数超乎想象，而且还有完善的中文文档可供阅读。 写博文完善自己的博客Hexo 支持 Markdown，但Markdown至今也没有几个称得上完美的编辑器，我使用的是微软家的 VSCode ，VSCode 支持基础的 Markdown 语法，但如果希望支持更多的语法，你需要安装 VSCode 的插件，或者自己造一个。正宗完善的 Markdown 可以支持很多东西，比如流程图，各种各样的表格，LaTeX等，如果用不到或者不想费劲学习，则使用图片就可以了。 我推荐的 Markdown 语法查询目录，是 SegmentFault 的 Markdown语法编辑器指南。这份指南足以满足大部分博客写作的要求了。 我碰到的问题 1，Hexo 部署失败，导致部署失败的原因有这几个： 网络环境差，导致无法push到github的博客仓库里，多执行几次 &quot;hexo deploy&quot; 命令可能就成功了； 解析出现错误，这种问题经常是配置文件写错了字母，或者在md文档中用错了Hexo的标签，查看终端输出的信息很容易发现问题的所在； git工具未找到，这种问题一种是安装了git，但环境变量没有配置成功，另外一种就是没有安装，这个时候应该回到Hexo的使用文档中查看自己漏掉了哪些步骤。 2，Hexo 解析的网页不显示图片，或者在主页中显示而在单独一篇文章中未显示： 这个是由于 Markdown 解析路径的问题，Hexo 的作者们好像并没有到Markdown解析中解决这个问题，虽然他们提出使用 相对路径引用的标签插件 ， 但我并没有使用成功，我的解决方法是安装了 Node.js 的 hexo-asset-image 模块，可以通过 npm install hexo-asset-image --save 来进行安装和使用。 3，我试图向 xxx.github.io 存放文件，却发现经常被 Hexo 删掉，这个需要注意一下。本打算将 Hexo 程序和博客原文一同放到 xxx.github.io中，看来是不行了，只好新建了一个库。 4，每次更新之后，最好是用 hexo clean 清理一下，防止发生一些错误。我的一些想法 应该利用空余时间研究下怎么样完善自己博客的功能，比如增加相册(图片应该找个图片云存放)等，写个主题什么的。","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"https://domacles.github.io/tags/blog/"}]},{"title":"C++11/14 简介","slug":"C++ 11 and 14 简介","date":"2017-03-01T08:32:04.000Z","updated":"2017-06-26T01:42:02.307Z","comments":true,"path":"2017/03/01/C++ 11 and 14 简介/","link":"","permalink":"https://domacles.github.io/2017/03/01/C++ 11 and 14 简介/","excerpt":"","text":"引言 C 与 C++ 的区别 C++ 11/14 中弃用的特性(不再推荐使用) 引言C++ 算是一个用户群体比较大的语言了，从 C++98 到 C++11 经历了长达十年多之久的积累，C++14 则是作为对 C++11 的重要补充和优化，所有这些新标准中扩充的特性，给 C++ 这门语言注入了新的活力。 那些还在坚持使用传统 C++ (本教程把 C++98 及其之前的 C++ 特性均称之为传统 C++)而未接触过 C++11/14 的 C++ 程序员在见到诸如 Lambda 表达式这类全新特性时，甚至会流露出『学的不是同一门语言』的惊叹之情。 C++1x (本教程中指 C++11/14, 甚至 C++17) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。C++1x 不仅仅增强了 C++ 语言自身的可用性，auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/… ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。 C++1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 std::thread 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex提供了完整的正则表达式支持等等。 C++98 已经被实践证明了是一种非常成功的『范型』，而 C++1x 的出现，则进一步推动这种范型，让 C++ 成为系统程序设计和库开发更好的语言。 C 与 C++ 的区别在程序设计思想上： C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。 C++首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“设计”这个概念已经被融入到C++之中。 在语法方面上, 下面两张图可以进行比较清晰的对比： http://en.cppreference.com/w/c/language http://en.cppreference.com/w/cpp/language 在标准库方面上，C的标准库是C++的子集： C Library C++ Containers C++ Atomics and threading library C++ Miscellaneous headers C++ Input/Output Stream Library C++ new library in furture 注：以上图片来自 C/C++ Reference. C++ 11/14 中弃用的特性(不再推荐使用) 如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。 不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto： 1char *str = &quot;hello world!&quot;; // 将出现弃用警告 C++ 98 异常说明、 unexcepted_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。 123// 下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常void old_stytle() throw(); // 不推荐使用void new_style() noexcept; // 新标准关键字 关于C++ Expection的概念以及使用，在未明确其概念之前，不推荐使用；可以在设计程序结构时禁止使用expection. auto_ptr 被弃用，应使用 unique_ptr，这个是属于标准库中对指针功能的增强。 register 关键字被弃用。该关键字在那个计算速度低下的年代，用于启用寄存器来增加运行速度。 bool 类型的 ++ 操作被弃用。(未曾使用过) C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。 123int n = 10;double x = (double) n; // 不再推荐使用double y = static_cast&lt;double&gt;(n); // 推荐使用 还有一些其他诸如参数绑定（C++11 提供了 std::bind 和 std::function）、export 等特性也均被弃用。前面提到的这些特性如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢，直接学习新特性。毕竟，技术是向前发展的。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://domacles.github.io/tags/C/"}]},{"title":"C++ 11/14 特性：新指针与新指针值","slug":"C++ 11 and 14 特性：新指针与新指针值","date":"2017-03-01T08:31:43.000Z","updated":"2017-06-26T01:42:02.307Z","comments":true,"path":"2017/03/01/C++ 11 and 14 特性：新指针与新指针值/","link":"","permalink":"https://domacles.github.io/2017/03/01/C++ 11 and 14 特性：新指针与新指针值/","excerpt":"","text":"指针类型的强化 空指针值的强化 使用指针的目的可以通过引用地址的方式，将某一对象能够送到其他作用域中进行操作。使用智能指针可以在一定程度上减少野指针以及内存泄漏的发生，但与此同时，若使用不当则会出现循环引用导致内存泄漏。使用nullptr可以将指针值与常量值0区分开，从而避免运行时出现函数参数类型匹配不当导致问题出现。 指针类型的强化智能指针（ shared_ptr 、 unique_ptr 、 weak_ptr ）, 废除 auto_ptr 。 shared_ptr 是一个引用计数智能指针，用于共享对象的所有权也就是说它允许多个指针指向同一个对象。 unique_ptr 是“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象，该指针生命周期结束后，会自动调用释放资源。 weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针， 它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期， 也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，常用与破除循环引用。 智能指针系列在声明的方式上与C指针声明并不相同，而是采用类构造函数式声明；智能指针系列都对 * 和 -&gt; 运算符进行了重载，使用方法与原指针相同。智能指针是基于引用计数器实现的，因此还可以读取当前有多少指针引用着对象。 关于引用计数器，可以搜索 Object-C 的引用计数进行学习和理解。 shared_ptr 使用概述:12345678910111213141516171819202122232425262728class Example&#123;public: Example() : e(1) &#123; cout &lt;&lt; &quot;Example Constructor...&quot; &lt;&lt; endl; &#125; ~Example() &#123; cout &lt;&lt; &quot;Example Destructor...&quot; &lt;&lt; endl; &#125; int e;&#125;;int main() &#123; shared_ptr&lt;Example&gt; pInt(new Example()); cout &lt;&lt; (*pInt).e &lt;&lt; endl; // cout &lt;&lt; pInt-&gt;e &lt;&lt; endl; cout &lt;&lt; &quot;pInt引用计数: &quot; &lt;&lt; pInt.use_count() &lt;&lt; endl; shared_ptr&lt;Example&gt; pInt2 = pInt; cout &lt;&lt; &quot;pInt引用计数: &quot; &lt;&lt; pInt.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;pInt2引用计数: &quot; &lt;&lt; pInt2.use_count() &lt;&lt; endl; return 0;&#125;Output Result:Example Constructor...pInt: 1pInt引用计数: 1pInt引用计数: 2pInt2引用计数: 2Example Destructor... 如上代码所示， shared_ptr 在进行赋值时会增加对象的引用，且该智能指针用法简洁明了。 shared_ptr 使用场景：C指针声明的地方都可以使用。 unique_ptr 使用概述：12345678unique_ptr&lt;int&gt; u_i; //创建空智能指针u_i.reset(new int(3)); //&quot;绑定”动态对象 unique_ptr&lt;int&gt; u_i2(new int(4)); //创建时指定动态对象 int *p_i = u_i2.release(); //释放所有权 unique_ptr&lt;string&gt; u_s(new string(&quot;abc&quot;)); unique_ptr&lt;string&gt; u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针” u_s2=nullptr; //显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价 unique_ptr 指针本身的生命周期：从 unique_ptr 指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过std::move移动语义转移所有权。 unique_ptr 使用场景： 空指针值的强化nullptr 代替了宏定义 NULL，在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://domacles.github.io/tags/C/"}]}]}